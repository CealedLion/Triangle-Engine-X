#version 450
#extension GL_KHR_vulkan_glsl : enable
#define PI 3.141592653589793238462643

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Particle {	
	vec4 Position;
	vec4 PositionVelocity;
	vec4 Magnitude;
	vec4 MagnitudeVelocity;
	vec4 Acceleration;
};

layout(std430, set = 0, binding = 0) buffer ParticlesBuffer0 {
	Particle ParticlesS[];
}Particles0;
layout(std430, set = 0, binding = 1) buffer ParticlesBuffer1 {
	Particle ParticlesS[];
}Particles1;

layout(push_constant) uniform PushConstantsComputeSimplified {
	int Part;
	int Particles;
	float Multiplier;

	float ElectrostaticOffset;
	float DiamagneticOffset;
	float MagneticOffset;

	float ElectrostaticStrength;
	float DiamagneticStrength;
	float MagneticStrength;

	float ElectrostaticAlignmentStrength;
	float DiamagneticAlignmentStrength;
	float MagneticAlignmentStrength;

	float maxpairing;
	float exponent;

}PushConstants;

//Model Settings
float MininiumInteractionDistance = 0.01f; //particles under this distance wont be interacted with to prevent infinites. 
float pairingrange = 0.01f; //distance where particles will optimize a electron pair to allow faster simulations.
float barycenterdistance = 0.01f; //distance from center of particle where magnetic field starts and particle interior ends.

float discomp = 0.1f;

//need to find out if there is a definitive value for any of these constants ;
//3 of them the offsets and electrostatic strength migth have definitive,
//use machine learning to solve the rest 
//but first make sure model is really accurate. ;

vec3 rotate (vec3 v, vec3 n, float a) {
	return v * cos(a) + cross(n, v) * sin(a) + n * dot(n, v) * (1. - cos(a));
}

struct calcreturn {
	vec3 pos;
	vec3 rot;
};
calcreturn Calculate_Electrostatic(Particle Particle0, Particle Particle1)
{
	calcreturn ret;
	//Normal Emission Force (electrostatic)
	vec3 relativevector = normalize((Particle0.Position.xyz * discomp) - (Particle1.Position.xyz * discomp));
	float r2decay = pow(distance((Particle0.Position.xyz * discomp), (Particle1.Position.xyz * discomp)) + PushConstants.ElectrostaticOffset, 2.0f);	
	ret.pos = (((Particle0.PositionVelocity.w * Particle1.PositionVelocity.w) * relativevector) / r2decay);
	ret.rot = vec3(0.0f);
	return ret;	
}
calcreturn Calculate_Magnetism(Particle Particle0, Particle Particle1, float closestelectronindexc, float i)
{ 
	calcreturn ret;		
	vec3 relativevector = normalize((Particle0.Position.xyz * discomp) - (Particle1.Position.xyz * discomp));

	//so what are double bonds 

	//oks so lets try to combine the radius with the new model and see if bonded radius is corrrecct 
	//ugh how the fuck do we make r adius work 

	//mayby electron proximity increases magnetic field strength? then mayby nucleas would be more paired. while not affecting outer electrons as much ;
	/*
	ratio so close but so far 

	seems like its always 1.65 to 1.38 
	
	i mean nothing so far made it higher then that 

	consider possibility that it might just be wrong? 

	but wtf could increase it at the same time 

	mayby just making more accurate in general ;

	SOMETHING HAS TOO MUCH REPULSION .. . .  id say its the outer elektrons as center already has literally 0 diamagnetic charge, unless of course electrostatic varies. 
	
	test offset, exponent and changing scales and electrostatic see if any affect the radius curve 

	*/
	//this determines the percentage of magnetic field that will pass through the particle and hence not extend further out 
	float factor = closestelectronindexc != -1 ? (closestelectronindexc == i ? 1.0f : 0.0f) : 0.0f;
	//factor = 1.0f;

	//so based on how much c cancels out i we scale totalmag from its current value to 1, so if c cancels out i completely then scaled totalmag should be 1 ,
	//while if c doesnt cancel out i at all then scaled totalmag should be its original value.;
	/*
	float r3decay = pow(distance((Particle0.Position.xyz * discomp), (Particle1.Position.xyz * discomp)) + PushConstants.MagneticOffset, 3);	

	float aaadit = -(-clamp(-(((((-acos(dot(Particle0.Magnitude.xyz, Particle1.Magnitude.xyz)) / PI) + 0.5f) * 2) * PushConstants.maxpairing)
			* Particle0.Magnitude.w * Particle1.Magnitude.w), -PushConstants.maxpairing, PushConstants.maxpairing) / r3decay) * pow(PushConstants.MagneticOffset, 3);		 

	float modifiedmag0 = clamp(Particle0.MagnitudeVelocity.w + (aaadit * 1), 0.0f, 1.0f);

	float modifiedmag1 = clamp(Particle1.MagnitudeVelocity.w + (aaadit * 1), 0.0f, 1.0f);
	*/
	//seems like everything is fucked, i think lets just go back to the natural curve + this mayby. 
	//wow ratio curve completely fucked ;

	center electrons oscilalte too mcuh probably because of this shit 

	solve the jittery thign problm 


	i think if electrons were closer it'd matter leess mayby 

	float modifiedmag0 = Particle0.Magnitude.w + (Particle0.Acceleration.x * PushConstants.exponent);
	float modifiedmag1 = Particle1.Magnitude.w + (Particle1.Acceleration.x * PushConstants.exponent);
	//float modifiedmag0 = Particle0.Magnitude.w;
	//float modifiedmag1 = Particle1.Magnitude.w;

	//bary center no mul exponent?? 
	vec3 polecp = (Particle0.Position.xyz * discomp) +  (Particle0.Magnitude.xyz * barycenterdistance) + ( relativevector * PushConstants.MagneticOffset * 0.5);
	vec3 polecn = (Particle0.Position.xyz * discomp) + -(Particle0.Magnitude.xyz * barycenterdistance) + ( relativevector * PushConstants.MagneticOffset * 0.5);
	vec3 poleip = (Particle1.Position.xyz * discomp) +  (Particle1.Magnitude.xyz * barycenterdistance) + (-relativevector * PushConstants.MagneticOffset * 0.5);
	vec3 polein = (Particle1.Position.xyz * discomp) + -(Particle1.Magnitude.xyz * barycenterdistance) + (-relativevector * PushConstants.MagneticOffset * 0.5);
	vec3 polepforce = vec3(0.0f);
	polepforce += (( relativevector * modifiedmag0 * modifiedmag1) / (4 * PI * pow(distance(polecp, poleip), 2.0f)));
	polepforce += ((-relativevector * modifiedmag0 * modifiedmag1) / (4 * PI * pow(distance(polecp, polein), 2.0f)));
	vec3 polenforce = vec3(0.0f);
	polenforce += (( relativevector * modifiedmag0 * modifiedmag1) / (4 * PI * pow(distance(polecn, polein), 2.0f)));
	polenforce += ((-relativevector * modifiedmag0 * modifiedmag1) / (4 * PI * pow(distance(polecn, poleip), 2.0f)));
	
	ret.pos = (polepforce + polenforce) * factor;

	//ret.rot = (polepforce - polenforce);

	//magnetic only r3 
	float r3decaymagnetismi = pow(distance((Particle0.Position.xyz * discomp), (Particle1.Position.xyz * discomp)) + PushConstants.MagneticOffset, 3.0f);
	//scale magneticorientationvector to set distance of magnetic field. 	
	vec3 orientationvectori = -(cross(cross(relativevector, Particle1.Magnitude.xyz), Particle1.Magnitude.xyz)) * barycenterdistance;
	//how compressed a given degree of the field is due to the particle obstruction.
	//seems like offsets and shit break conservation ;

	//float fieldcompressionfactori = clamp((((acos(dot(normalize(orientationvectori), relativevectori)) / PI) * 2) - 0.8f) * 2, 0.0f, 1.0f);
	float fieldcompressionfactori = clamp((((acos(dot(normalize(orientationvectori), relativevector)) / PI) * 2) - 0.5f), 0.0f, 1.0f);
	
	//scale by fieldcomrpresion factor adds vector to forcedirection to make it more accurate. ;
	//the further it gets from other particle the less it aligns, negative feedback loop ;
	//so the solution is theres a force that pushes from equator to poles ;
	vec3 relativevectortrue = normalize(relativevector - (orientationvectori * pow(1 + fieldcompressionfactori, 30)));
	//force going towards poles either way from equator.
	vec3 polarforce = cross(cross(normalize(orientationvectori), relativevectortrue), relativevectortrue);
	 
	//REAR PAIRING IS LESS SRTONG >:c ACTUALLY DUE TO CANCELLATION FORCE.; so what. cancellation should reduce on the primary particle..
	
	//now find direction of it
	vec3 forcedirectioni = normalize(cross(cross(normalize(orientationvectori), Particle1.Magnitude.xyz), relativevectortrue));

	ret.rot = (((-forcedirectioni * modifiedmag0 * modifiedmag1)) / r3decaymagnetismi) * factor;
		// * (((-acos(dot(Particle0.Magnitude.xyz, forcedirectioni)) / PI) + 0.5f) * 2)*/

	//i think each pole having a torque moment and the more force exerted the more rotation? ;

	//Magnetic Particle Precession Motion In Magnetic Field Transform.
	//rate of precession, theres an equilibrium where the amount of energy deflected by precession = total force exerted;
	//the combined forced should be a combination of this making it precess, and the other one making it normalize;
	//calculating the strength of the precession relative to the normalization is extremely difficult.;

	//precession is kind of janky really whether its relevant depends on how strong it is and we have no way to tell that. ;

	//magnetic precession is the weirdestshit ever
	//i feel like it only happens ina very specific edge case
	//like 95%+ uniform magnetic field

	//ret.rot += cross(cross(Particle1.Magnitude.xyz, relativevector), relativevector) * Particle0.MagnitudeVelocity.w * Particle1.MagnitudeVelocity.w * 0.0001f;

	return ret;	
}
calcreturn Calculate_Diamagnetism(Particle Particle0, Particle Particle1, float closestelectronindexc, float i)
{
	calcreturn ret; 
	vec3 relativevector = normalize((Particle0.Position.xyz * discomp) - (Particle1.Position.xyz * discomp));
	
	//magnetic part bv 
	float magneticfactor = 0.0f;
	/*
	assymetrical diamagnetism ;

	we have 3 options, 
	1. all with one system that has deadzones, 
	2. all with the other system
	3. combination
	;
	*/
	//asymmetrical diamagnetism is kind of required bro ;
	/*
	0-1 offset has correct radius but not even fully correct because the curve to boron is wrong and higher dont work 

	but 0.5-1.0-1 is better in every where else, but radius is wrong, so would need a mechanic to fix radius, 
	like field compression 
	*/

	//magnetic only r3 
	//float r3decaymagnetismi = pow(distance((Particle0.Position.xyz * discomp), (Particle1.Position.xyz * discomp)) + PushConstants.MagneticOffset, 3.0f);
	//scale magneticorientationvector to set distance of magnetic field. 	
	vec3 orientationvectori = -(cross(cross(relativevector, Particle1.Magnitude.xyz), Particle1.Magnitude.xyz)) * barycenterdistance;
	//how compressed a given degree of the field is due to the particle obstruction.

	float fieldcompressionfactori = clamp(((acos(dot(normalize(orientationvectori), relativevector)) / PI) * 100) - 49.0f, 0.0f, 1.0f);

	//fieldcompressionfactori = Particle1.Acceleration.y == -1 ? fieldcompressionfactori : 1.0f;
	fieldcompressionfactori = 1.0f;


	float factor = closestelectronindexc != -1 ? (closestelectronindexc == i ?  0.0f : 1.0f) : 1.0f;
	//float factor = 1;

	magneticfactor +=  (1 / pow(distance((Particle0.Position.xyz * discomp), (Particle1.Position.xyz * discomp)) + PushConstants.MagneticOffset, 3.0f)) * (Particle0.MagnitudeVelocity.w + Particle1.MagnitudeVelocity.w) * factor;
	/*
	{
	vec3 polecp = (Particle0.Position.xyz * discomp) +  (-Particle1.Magnitude.xyz * barycenterdistance) + ( relativevector * PushConstants.MagneticOffset * 0.5);
	vec3 polecn = (Particle0.Position.xyz * discomp) + -(-Particle1.Magnitude.xyz * barycenterdistance) + ( relativevector * PushConstants.MagneticOffset * 0.5);
	vec3 poleip = (Particle1.Position.xyz * discomp) +  (-Particle1.Magnitude.xyz * barycenterdistance) + (-relativevector * PushConstants.MagneticOffset * 0.5);
	vec3 polein = (Particle1.Position.xyz * discomp) + -(-Particle1.Magnitude.xyz * barycenterdistance) + (-relativevector * PushConstants.MagneticOffset * 0.5);
	vec3 polepforce = vec3(0.0f);
	polepforce += (( relativevector * Particle1.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecp, poleip), 2.0f)));
	polepforce += ((-relativevector * Particle1.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecp, polein), 2.0f)));
	vec3 polenforce = vec3(0.0f);
	polenforce += (( relativevector * Particle1.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecn, polein), 2.0f)));
	polenforce += ((-relativevector * Particle1.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecn, poleip), 2.0f))); 
	magneticfactor += length(polepforce + polenforce)              *  Particle0.MagnitudeVelocity.w;
	}
	//there might be case where this is independant from main magnetic and electrostatic strength;
	//for example if the actual force exerted is different from how density interects with force.;
	//i think it possibly is slightly detached from it;

	//changing these strength is illegitimate, only changing strength of diamagnetic is legitimate as it represents interaction affinity which 
	//doesnt change the ratios of force. ;
	magneticfactor = magneticfactor * PushConstants.MagneticStrength * 100;
	*/
	magneticfactor = magneticfactor * PushConstants.MagneticStrength * 0.1f;
	
	//electrostatic part 
	float r2decay = pow((distance((Particle0.Position.xyz * discomp), (Particle1.Position.xyz * discomp)) + PushConstants.ElectrostaticOffset), 2.0f);	
	//float electrostaticfactor = length(((((abs(Particle0.PositionVelocity.w) + abs(Particle1.PositionVelocity.w)) / 2) * relativevector) / r2decay) * PushConstants.ElectrostaticStrength);	
	float electrostaticfactor = length((abs(Particle0.PositionVelocity.w * Particle1.PositionVelocity.w) * relativevector) / r2decay) * PushConstants.ElectrostaticStrength * 0.01f;

	ret.pos = (magneticfactor * electrostaticfactor) * relativevector;	
	
	//ret.rot = (electrostaticfactor) * relativevector * (Particle1.PositionVelocity.w > 0 ? 1.0f : 0.0f);
	ret.rot = (electrostaticfactor) * relativevector;
	return ret;	
}

void main(void)
{
	if (PushConstants.Part == 0)
	{	
	/*
	TODO:

	electrodynamics/EM radiation simulation
	
	proper thermodynamic regulation force that makes the simulation at a set temperature. 
	proper pressure simulation and container simulation
 
	and the other minor forces like precession and circular path in magnetic field 

	v^2 momemtum add ? 

	lorentz transformation
	1 / (1 / sqrt(1 -  (pow(v, 2) / pow(c, 2))))
	cos(arcsin(v / c)) 
	*/	

	//we cant ignore these forces, they will affect the dynamics, t he plan is to add all the axulitary stuff
	//then the main problem should be just solved by force adjust.;

	/*
	make a list of all possible missing forces from this model.

	ELECTROSTATIC:

	DIAMAGNETIC:
	1. hypothetical diamagnetic alignment force like electrostatic one.

	MAGNETIC:
	1. precession 
	2. force cross product to magnetic field vector and velocity 
	3. 
	*/
	/*
	whatever fuckiing meme we have now "works" but it is no where near halal,
	but its basicially just increased magnetism for paired electron

	its basicially assumption that magnetism is for some reason much higher for the one paired electron. 

	mayby diamagnetism does the same thing, bu tprobably not electrostatic 

	*/

	vec3 totalpos = vec3(0.0f);
	vec3 totalrot = vec3(0.0f);

	float chargec = Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.w;
	float massc = Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w;
	float spinc = Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w;
 
	float closestelectrondistancec = 999999999999.0f;
	float closestelectronindexc = -1.0f;

	float totalaag = 0.0f;
	for (int i = 0; i < PushConstants.Particles; i++) 
	{	
		if (gl_GlobalInvocationID.x != i)
		{	
			float chargei = Particles0.ParticlesS[i].PositionVelocity.w;		
			float massi = Particles0.ParticlesS[i].Position.w;		
			float spini = Particles0.ParticlesS[i].Magnitude.w;		
			float disci = distance((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp), (Particles0.ParticlesS[i].Position.xyz * discomp));		
				
			//mayby cancelled out should not affect 
			/*hmm cancelled out not affecting dopes fucking nothing


			although we found out the ratio between 4 and 5 increases as we keep increasing the things 

			but the ratio relative to 3 will be completely wrong 

			so if lithium is more affected by the mechanisms it might be able to be more accurate,

			pairing famously doesnt affect lithium... but the induction does... hmmm 

			mayby thats why the ratio curve was improved recently over previous versions 

			*/


			float r3decay = pow(distance((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp), (Particles0.ParticlesS[i].Position.xyz * discomp)) + PushConstants.MagneticOffset, 3);		



			totalaag += ((Particles0.ParticlesS[i].Acceleration.y == -1 ? 1.0f : 0.0f) * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w * Particles0.ParticlesS[i].Magnitude.w) / r3decay;	

			

			closestelectronindexc = (disci < closestelectrondistancec && spini != 0.0f && spinc != 0.0f) ? i : closestelectronindexc;	
			closestelectrondistancec = (disci < closestelectrondistancec && spini != 0.0f && spinc != 0.0f) ? disci : closestelectrondistancec;
		}
	}
	closestelectronindexc = Particles0.ParticlesS[int(closestelectronindexc)].Acceleration.y == -1 ? closestelectronindexc : -1.0f;
	closestelectronindexc = Particles0.ParticlesS[int(gl_GlobalInvocationID.x)].Acceleration.y == -1 ? closestelectronindexc : -1.0f;


	float pairedparticleindex = -1.0f;
	float closestelelectronindexa = -1.0f;
	float closestelelectronindexb = -1.0f;
	//float method vs vector method virtually identical. 
	float totalmag = Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w;
	for (int i = 0; i < PushConstants.Particles; i++) 
	{	
		if (gl_GlobalInvocationID.x != i)
		{	
			float chargei = Particles0.ParticlesS[i].PositionVelocity.w;		
			float massi = Particles0.ParticlesS[i].Position.w;		
			float spini = Particles0.ParticlesS[i].Magnitude.w;		
			float disci = distance((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp), (Particles0.ParticlesS[i].Position.xyz * discomp));		

			float r3decay = pow(distance((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp), (Particles0.ParticlesS[i].Position.xyz * discomp)) + PushConstants.MagneticOffset, 3);		

			totalmag += (-clamp(-(((((-acos(dot(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, Particles0.ParticlesS[i].Magnitude.xyz)) / PI) + 0.5f) * 2) * PushConstants.maxpairing)
						* Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w * Particles0.ParticlesS[i].Magnitude.w), -PushConstants.maxpairing, PushConstants.maxpairing) / r3decay) * pow(PushConstants.MagneticOffset, 3);		 

			//optimization indices 
			pairedparticleindex =		(disci < pairingrange && spini != 0.0f && spinc != 0.0f) ? i : pairedparticleindex;					
			closestelelectronindexb =	(disci < MininiumInteractionDistance && spini == 0.0f && spinc != 0.0f && closestelelectronindexa != -1) ? i : closestelelectronindexb;	
			closestelelectronindexb =	(disci < MininiumInteractionDistance && spini != 0.0f && spinc == 0.0f && closestelelectronindexa != -1) ? i : closestelelectronindexb;			
			closestelelectronindexa =	(disci < MininiumInteractionDistance && spini == 0.0f && spinc != 0.0f && closestelelectronindexa == -1) ? i : closestelelectronindexa;	
			closestelelectronindexa =	(disci < MininiumInteractionDistance && spini != 0.0f && spinc == 0.0f && closestelelectronindexa == -1) ? i : closestelelectronindexa;				
			//forces
			if (disci > MininiumInteractionDistance)  
			{ 		
			//Electrostatic
			calcreturn Electrostaticitoc = Calculate_Electrostatic(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i]);
			totalpos += Electrostaticitoc.pos * PushConstants.ElectrostaticStrength * 0.01f;
			totalrot += Electrostaticitoc.rot * PushConstants.ElectrostaticAlignmentStrength;	
			//Magnetism
			calcreturn Magnetismitoc = Calculate_Magnetism(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i], closestelectronindexc, float(i));	
			totalpos += Magnetismitoc.pos * PushConstants.MagneticStrength * 100.0f;
			totalrot += Magnetismitoc.rot * PushConstants.MagneticAlignmentStrength * 1.0f;	
			//Diamagnetism
			calcreturn Diamagnetismitoc = Calculate_Diamagnetism(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i], closestelectronindexc, float(i));	
			totalpos += Diamagnetismitoc.pos * PushConstants.DiamagneticStrength * 0.10f;
			totalrot += Diamagnetismitoc.rot * PushConstants.DiamagneticAlignmentStrength * 1.0f;	
			}
		}
	}

	Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.w = spinc == 0.0f ? 0.0f : (closestelelectronindexa != -1 ? 0.0f : clamp(totalmag, 0.0f, 1.0f));

	Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x = totalaag;

	Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.y = closestelelectronindexa;
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z = closestelelectronindexb;
	//range checks 
	totalpos = length(totalpos) > 0.0f ? totalpos : vec3(0.0f);
	totalpos = length(totalpos) < 100000.0f ? totalpos : vec3(0.0f);
	totalrot = length(totalrot) > 0.0f ? totalrot : vec3(0.0f);
	totalrot = length(totalrot) < 100000.0f ? totalrot : vec3(0.0f);

	//final addition
	Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += totalpos * (PushConstants.Multiplier * 0.5f);
	Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz += totalrot * (PushConstants.Multiplier * 0.5f);
	
	//crucial for integrator 
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz = Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz;
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;

	}
	if (PushConstants.Part == 1)
	{	
	Particles0.ParticlesS[gl_GlobalInvocationID.x] = Particles1.ParticlesS[gl_GlobalInvocationID.x];
	
	{//temporary slowdown effect aka cooling
		float bleed = 1.0f - (0.3f * PushConstants.Multiplier);
		Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * bleed;
		Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz = Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz * bleed;
	}
	//container 
	//if (length(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp)) > 10.0f)
	//{
	//	Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (normalize(-Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp)) * 0.00001f) * PushConstants.Multiplier;
	//}

	float chargec = Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.w;
	float massc = Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.w;
	float spinc = Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w;

	//float pairedparticleindex = Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x;
	float closestelelectronindexa = Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.y; 
	float closestelelectronindexb = Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z;

	//POSITION
	
	//paired and nuclear position additions.
	/*
	Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz = spinc == 0.0f ? Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz : 
		(pairedparticleindex != -1 ? (closestelelectronindexa != -1 ? Particles1.ParticlesS[int(closestelelectronindexa)].Position.xyz : (Particles1.ParticlesS[int(pairedparticleindex)].Position.xyz + Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) / 2) :
		(closestelelectronindexa != -1 ? Particles1.ParticlesS[int(closestelelectronindexa)].Position.xyz : Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz));
	Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz += ((spinc == 0.0f ? (Particles1.ParticlesS[int(closestelelectronindexa)].PositionVelocity.xyz + Particles1.ParticlesS[int(closestelelectronindexb)].PositionVelocity.xyz + Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz): 
		(pairedparticleindex != -1 ? (closestelelectronindexa != -1 ? vec3(0.0f) : (Particles1.ParticlesS[int(pairedparticleindex)].PositionVelocity.xyz + Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) / 2) :
		(closestelelectronindexa != -1 ? vec3(0.0f) : Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz))) / massc) * (PushConstants.Multiplier * 1.0f);
	*/
	
	Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz = spinc == 0.0f ? Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz : 
		(closestelelectronindexa != -1 ? Particles1.ParticlesS[int(closestelelectronindexa)].Position.xyz : Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz);
	Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz += ((spinc == 0.0f ? (Particles1.ParticlesS[int(closestelelectronindexa)].PositionVelocity.xyz + Particles1.ParticlesS[int(closestelelectronindexb)].PositionVelocity.xyz + Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) : 
		(closestelelectronindexa != -1 ? vec3(0.0f) : Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)) / massc) * (PushConstants.Multiplier * 1.0f);
	

	//unpaired ver
	//Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) = Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp);	
	//Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) += ((Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) / massc) * (PushConstants.Multiplier * 1.0f);
		//something is wrong with magnitude some deadzone 
	//MAGNITUDE	
	//paired magnitude additions.
	//potentially invalid if multiple rotational transforms are added together like totalrot.;	
	
	//vec3 combinedtransform = (Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz + Particles1.ParticlesS[int(pairedparticleindex)].MagnitudeVelocity.xyz) / 2;
	//vec3 newmagnitudetransform = pairedparticleindex != -1 ? (distance(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, combinedtransform) < distance(Particles1.ParticlesS[int(pairedparticleindex)].Magnitude.xyz, combinedtransform) ?
	//combinedtransform : -combinedtransform) : Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz;
	
	//why when rotation force set to 0 it breaks; 
	//probably because same reason why it breaks when no check, and having residual velocity passes the check or something. 
	//when magnitudevelocity is 0 its really bad, we changed length(newmagnitudetransform) > 0.001f instead of length(newmagnitudetransform) != 0.0f

	vec3 newmagnitudetransform = Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz;
	//temporary just to stop nuclear electrons from beign retarded
	//newmagnitudetransform = pairedparticleindex != -1 ? vec3(0.0f) : newmagnitudetransform;
	newmagnitudetransform = closestelelectronindexa != -1 ? vec3(0.0f) : newmagnitudetransform;

	if (length(newmagnitudetransform) > 0.001f &&
		length(cross(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(newmagnitudetransform))) > 0.001f &&
		length(cross(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(-newmagnitudetransform))) > 0.001f)
	{
	//rotating magnitude according to magnitudevelocity.
	Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = rotate(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, 
		cross(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(newmagnitudetransform)),
		((acos(dot(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(newmagnitudetransform))) * length(newmagnitudetransform)) / massc) * (PushConstants.Multiplier * 1.0f));
	//needs velocity to be rotated to exactly how much magnitude is  
	Particles0.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz = rotate(Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz, 
		cross(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(newmagnitudetransform)),
		((acos(dot(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(newmagnitudetransform))) * length(newmagnitudetransform)) / massc) * (PushConstants.Multiplier * 1.0f));

	Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz);
	}
	
	
	
	//Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = pairedparticleindex != -1 ? vec3(1, 0, 0) : Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;
	}
}


	/*
	//magnetic only r3 
	float r3decaymagnetismi = pow((distance(Particle0.Position.xyz * discomp), Particle1.Position.xyz * discomp)) + MagneticOffset), 3.0f);
	//vector between field center and particle
	vec3 relativevectori = normalize(Particle0.Position.xyz * discomp) - Particle1.Position.xyz * discomp));
	//scale magneticorientationvector to set distance of magnetic field. 	
	vec3 orientationvectori = -(cross(cross(relativevectori, Particle1.Magnitude.xyz), Particle1.Magnitude.xyz)) * barycenterdistance;
	//how compressed a given degree of the field is due to the particle obstruction.
	//seems like offsets and shit break conservation ;

	//float fieldcompressionfactori = clamp((((acos(dot(normalize(orientationvectori), relativevectori)) / PI) * 2) - 0.8f) * 2, 0.0f, 1.0f);
	float fieldcompressionfactori = clamp((((acos(dot(normalize(orientationvectori), relativevectori)) / PI) * 2) - 0.5f), 0.0f, 1.0f);
	
	//scale by fieldcomrpresion factor adds vector to forcedirection to make it more accurate. ;
	//the further it gets from other particle the less it aligns, negative feedback loop ;
	//so the solution is theres a force that pushes from equator to poles ;
	vec3 relativevectortrue = normalize(relativevectori - (orientationvectori * pow(1 + fieldcompressionfactori, 30)));
	//force going towards poles either way from equator.
	vec3 polarforce = cross(cross(normalize(orientationvectori), relativevectortrue), relativevectortrue);
	 
	//REAR PAIRING IS LESS SRTONG >:c ACTUALLY DUE TO CANCELLATION FORCE.; so what. cancellation should reduce on the primary particle..
	
	//now find direction of it
	vec3 forcedirectioni = normalize(cross(cross(normalize(orientationvectori), Particle1.Magnitude.xyz), relativevectortrue));
	//magnetism from orbital veloecity (UNFIINISHED)
	//vec3 forcedirectionfromvelocity = cross(Particles0.ParticlesS[i].PositionVelocity.xyz, );
	//Magnetic Particle Circular Motion In Magnetic Field Transform.
	//totalpos += cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz, totalmagdirectioni) * 0.000001f;
	//Magnetic Drag Positional Transform
	//totalpos += (length(totalmagdirectioni) * -(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)) * 0.0000001f;	
	//Magnetic Particle Precession Motion In Magnetic Field Transform.
	//rate of precession, theres an equilibrium where the amount of energy deflected by precession = total force exerted;
	//the combined forced should be a combination of this making it precess, and the other one making it normalize;
	//calculating the strength of the precession relative to the normalization is extremely difficult.;
	//totalrot += cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, totalmagdirectioni) * 0.000001f;
	//Magnetic Particle Alignment Transform.
	//totalrot += (totalmagdirectioni * -((((-acos(dot(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, normalize(totalmagdirectioni))) / PI) + 0.5f) * 2) + 0.5f)) * 0.0000001f;

	float magmul = (Particle0.Acceleration.x + Particle0.Magnitude.w) * (Particle1.Acceleration.x + Particle1.Magnitude.w);
	ret.pos = vec3(0.0f);
	ret.pos += ((relativevectori * magmul) / r3decaymagnetismi) *
					(((-acos(dot(Particle0.Magnitude.xyz, forcedirectioni)) / PI) + 0.5f) * 2);
	how strong should polar force be. it depends on how far from equator, directly proportional to field compression factor . . .
	when field comrpession factor = 1 it is as strong as relativevector transform. 

	ret.pos += ((polarforce * magmul) / r3decaymagnetismi) *
				(((-acos(dot(Particle0.Magnitude.xyz, forcedirectioni)) / PI) + 0.5f) * 2);
	//it doesnt need it needs alignment because of the nature of how magnitude is calculated atm.
	ret.rot = (((-forcedirectioni * (Particle0.Acceleration.x + Particle0.Magnitude.w) * (Particle1.Acceleration.x + Particle1.Magnitude.w))) / r3decaymagnetismi);
		// * (((-acos(dot(Particle0.Magnitude.xyz, forcedirectioni)) / PI) + 0.5f) * 2)*/



	//this is not right;
	//Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.w = spinc != 0.0f ? clamp(length(totalmag), 0.5, 1.0f) : 0.0f;
	//Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.w = clamp(totalmag, 0.0f, 1.0f);


				/*
			induction magnetism;
			but what causes induction? 		
			paired particles rotate? but then valence doesnt produce spectra.. so ugh how 
			theres also distinct layers of excitaiton : / like in hydrogen : / / / 
			wait magnitude rotation can also cause EM emission .. . .

			1. the determinant of the energy levels must be nucleus and other electrons. 
			2. must be able to boost and negate to different energy levels
			3. must have quantized difference . .. . 

			what if its some sort of waveform mixing that results in neat spectra 
			waveform mixing doesnt change frequency hmm just reduces amplitude vb 
			it doesnt really matter if other frequencies are emitted too, just that they cnacel eaechother out 
			i mean the electrons just have to be oscillating in some way. 
			its already probably fine  
			
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x = 0.0f;
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x = spini == 0.0f && spinc != 0.0f ?
			//			((1 / pow(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp), Particles0.ParticlesS[i].Position.xyz * discomp)) + MagneticOffset, 3)) * Inductionmagnetismstrength) : Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x;
			*/


					/*
			next step readd polarization dynamics and fine tune them.;
			fiugre out how the 3 forces change rotation;

			1. electrostatic doesnt need rot because diamagnetism is electrostatic interacting with magnetic field so its redundant. and torque from hitting particle itself assymetrically is basicialyl impossible
			2. diamagnetism torque solved by every source creates a polarization force either alignes perpindicularly or parrelel to force vector (already done);
			3. magnetic torque (EXPLAIN) aaa uniform magnetic field only precession? ugh ;
			it is complicated because we know that it precesses but mayby shouldnt it align? or does magnetism just not align particles at all. ? 
			but like there has to be some form of magnetic alignment rigth? or is it all just diamagnetism perpindicular?;
			perpindicular doesnt realy make sense what direction itd align and the structure is inferior. 

			so there must be a magnetic transform of some sort right, so what is it? because precession has to be included;

			1. precession with very slow alignmnet : / not realy
			2. preccession in uniform fields and alignment in non uniform ? i think this is most promising ngl because of the dichotemy. 
			*/	
		
			//Perpindicular Emission Force (light)			
			//a particle accelerated in direction x signicantly enough it releases perpindicular energy that induces motion in particles in direction -x.;
			//also when a particles magnetic field is hit it creates a copy of the impacting wave.;
			//needs to follow dominant frequency theory too;
			//totalpos += ((chargec * chargei) * ((length(Particles1.ParticlesS[i].Acceleration.xyz) > Threshold) ? (-Particles1.ParticlesS[i].Acceleration.xyz / r2decay) : vec3(0.0f))) * 0.1f;
			//Gravitational Force
			//totalpos += ((1.0 / 404331557902116024553602703216.58) / distancesqaured) * pParticle2->Size; // ((0.00000000001) / distancesqaured) * pParticle2->Size
			
			//bonding requires partial pairing but full pairing is more accurate for structure 
			//option a, special case magnetism, self centering. ;
			//so basicially the closer a particle is to a nucleus the more of its magnetism is centered. 
			//it shouldnt add more magnitude then what was already present ; so normalize it by relativevectori ;
			//float decayr3np = pow(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp), Particles0.ParticlesS[int(Particles0.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z)].Position.xyz * discomp)) + MagneticOffset, 3.0f);
			//vec3 nuclearpolarization = normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) - Particles0.ParticlesS[int(Particles0.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z)].Position.xyz * discomp)) / decayr3np;
			//the percentage of relative vector that becomes aligned with nucleus depends on how close it is. r3 or r2;
			//btw this is only the case if there is a paired particle aligned oppisite on the other side of nucleus. symmetrically. so include that.;
			//relativevectori = Particles0.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z != -1 ? 
			//			 ((nuclearpolarization + relativevectori) * (length(relativevectori) / length((nuclearpolarization + relativevectori)))) : relativevectori;


	/*
				/*
			//barycenter of where electrostatic force hits c parrticle from i particle and disperses energy into the lattice. 
			vec3 forcecenteritoc = (Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) + Particles0.ParticlesS[i].Position.xyz * discomp)) / 2;	
			float baselineitoc = distance(forcecenteritoc, Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp));
			for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
			{	
				//it is 1 divisor too much, it starts at 2 . ;
				//why does  * Particles0.ParticlesS[i2].MagnitudeVelocity.w break energy conservation ;
				//oh because it makes 0 and 1 (c and i ) have non 2 divisor 
				float ea = (i2 != gl_GlobalInvocationID.x && i2 != i) ? (Particles0.ParticlesS[i2].Acceleration.x == -1 ? Particles0.ParticlesS[i2].MagnitudeVelocity.w : 0.0f) : 1.0f;
				//ea = (i2 != gl_GlobalInvocationID.x && i2 != i) ? 0.0f : 1.0f;
				//distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz * discomp)) <= baselineitoc
				//also baseline check is required? but need sto be better... baseline makes it jittery
				//divisor += true ? ((1 / pow((distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz * discomp)) / baselineitoc) + MagneticOffset, 3.0f)) * ea) : 0.0f;		
			}
			{
			calcreturn Diamagnetismitoc = Calculate_Diamagnetism(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i], divisor);
			/*if the barycenter is inbetween the 2 particles then lattice litterally doesnt exist 
			vec3 Diamagnetismlattice = vec3(0.0f);
			for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
			{	
				if (gl_GlobalInvocationID.x != i2 && i != i2)
				{	
					float disci2 = distance(Particles0.ParticlesS[i].Position.xyz * discomp), Particles0.ParticlesS[i2].Position.xyz * discomp));
					if (disci2 > MininiumInteractionDistance) 
					{
					Diamagnetismlattice += Calculate_LatticeDiamagnetism(Particles0.ParticlesS[i], Particles0.ParticlesS[i2], int(gl_GlobalInvocationID.x));
					}
				}
			}		
			totalpos += Diamagnetismlattice * DiamagneticStrength;	
			totalpos += Diamagnetismitoc.pos * DiamagneticStrength;	
			totalrot += Diamagnetismitoc.rot * MagneticAlignmentStrength;	
			}
			{
			calcreturn Magnetismitoc = Calculate_Magnetism(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i], divisor);
			/*if the barycenter is inbetween the 2 particles then lattice litterally doesnt exist 
			vec3 Magnetismlattice = vec3(0.0f);
			for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
			{	
				if (gl_GlobalInvocationID.x != i2 && i != i2)
				{	
					float disci2 = distance(Particles0.ParticlesS[i].Position.xyz * discomp), Particles0.ParticlesS[i2].Position.xyz * discomp));
					if (disci2 > MininiumInteractionDistance) 
					{
					Magnetismlattice += Calculate_LatticeMagnetism(Particles0.ParticlesS[i], Particles0.ParticlesS[i2], int(gl_GlobalInvocationID.x));
					}
				}
			}		
			//totalpos += Magnetismlattice * MagneticStrength;	
			totalpos += Magnetismitoc.pos * MagneticStrength;		
			totalrot += Magnetismitoc.rot * MagneticAlignmentStrength;	
			}


	for (int i = 0; i < PushConstants.Particles; i++) 
	{	
		if (gl_GlobalInvocationID.x != i)
		{	
			float chargei = Particles0.ParticlesS[i].PositionVelocity.w;		
			float massi = Particles0.ParticlesS[i].Position.w;		
			float spini = Particles0.ParticlesS[i].Magnitude.w;		
			float disci = distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp), Particles0.ParticlesS[i].Position.xyz * discomp));
			
			float r3decay = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp), Particles0.ParticlesS[i].Position.xyz * discomp)) + MagneticOffset), 6.0f);
			totalmag += ((Particles0.ParticlesS[i].Magnitude.xyz * Particles0.ParticlesS[i].Magnitude.w) / r3decay) * pow(MagneticOffset, 6.0f);		

			//if interacting particle and current particle are electrons and they are close enough, they pair. is exclusive.
			pairedparticleindex = (disci < pairingrange && spini != 0.0f && spinc != 0.0f) ? i : pairedparticleindex;	
			closestelelectronindexa = (disci < MininiumInteractionDistance && spini == 0.0f && spinc != 0.0f) ? i : closestelelectronindexa;	
			closestelelectronindexa = (disci < MininiumInteractionDistance && spini != 0.0f && spinc == 0.0f) ? i : closestelelectronindexa;	
		}
	}*/
	//float r3decaye = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp), Particles0.ParticlesS[int(closestelelectronindexa)].Position.xyz * discomp)) + MagneticOffset), 3.0f);
	//vec3 averagedir = spinc != 0.0f ? (normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) - Particles0.ParticlesS[int(closestelelectronindexa)].Position.xyz * discomp)) / r3decaye) : vec3(0.0f);
	//it needs to be the average density over the path of electrostatic from center of particle to other particle. ; i dont think its sqrt its linear
	//spinc of nucleus cant be canceled out unless its a fucking nucleus with net spin. but its always cancelled out
	//Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.w = (spinc != 0.0f ? clamp(length(totalmag), 0.5f, 1.0f) : 0.5f); // + (1 / r3decaye)
	//Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.w = (spinc != 0.0f ? clamp(length(totalmag), 0.5f, 1.0f) : 0.0f);
	//totalrot += ((distance(-averagedir, Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz) < distance(averagedir, Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz)) ? -averagedir : averagedir) * ForceInducedRotationStrength;	

	//innermost eletrons definetely do have a few forces helping.;
	//totalrot += pairedparticleindex == -1 ? vec3(0.0f) : -Particles0.ParticlesS[int(pairedparticleindex)].Magnitude.xyz;
	//add something to lock central electrons for optimization;
	//totalpos += distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp), Particles0.ParticlesS[int(closestelelectronindexa)].Position.xyz * discomp)) < (MininiumInteractionDistance * 2) ?
	//			(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) - Particles0.ParticlesS[int(closestelelectronindexa)].Position.xyz * discomp)) : vec3(0.0f);

/*

vec3 Calculate_LatticeDiamagnetism(Particle Particle0, Particle Particle1, int c, int i)
{
	float r23decaydiamagnetismi = pow((distance(Particle0.Position.xyz * discomp), Particle1.Position.xyz * discomp)) + MagneticOffset), 6.0f);
	//electrostatic flux strength determines repulsion strength.
	vec3 forcepos = abs(Particle1.PositionVelocity.w * Particle0.PositionVelocity.w) * (normalize(Particle0.Position.xyz * discomp) - Particle1.Position.xyz * discomp)) / r23decaydiamagnetismi);			
	//barycenter of where electrostatic force hits c parrticle from i particle and disperses energy into the lattice. 
	//biased to one side? it seems like 0.5 makes difference between hydrogen and helium less rather then 0.1 hmmm...
	//0.8 is less accurate then 0.5 and 0.1 is less accurate hten 0.5 
	//theoretical predictions say it should be from like 0.5-0.8 on average.
	//vec3 forcecenteritoc = Particle1.Position.xyz * discomp) + ((Particle0.Position.xyz * discomp) - Particle1.Position.xyz * discomp)) * percentoffset);	
	vec3 forcecenteritoc = (Particle1.Position.xyz * discomp) + Particle0.Position.xyz * discomp)) / 2;
	//it can take its own lattice tho ; instead, lattice set originaly to 0. ;
	float aa = 0.0f;
	float lowpointitoc = 0.0f;
	float baselineitoc = distance(forcecenteritoc, Particle0.Position.xyz * discomp));
	for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
	{	
		float e = distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz * discomp)) <= baselineitoc ?
						((1 / pow((distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz * discomp)) / baselineitoc) + MagneticOffset, 6.0f)) * Particles0.ParticlesS[i2].MagnitudeVelocity.w) : 0.0f;	
		//if i2 = c then save how much it adds and then divide that by the total divisor to get the percentage of the force that c has got. ;
		lowpointitoc += e;
	//	pretty sure this breaks energy conservation because izz un balance   
		aa = (i2 == c) ? e : aa;
	}
	return ((forcepos * Particle1.MagnitudeVelocity.w * Particle0.MagnitudeVelocity.w) / lowpointitoc) * (aa / lowpointitoc);
}
vec3 Calculate_LatticeMagnetism(Particle Particle0, Particle Particle1, int c, int i)
{
	float r23decaydiamagnetismi = pow((distance(Particle0.Position.xyz * discomp), Particle1.Position.xyz * discomp)) + MagneticOffset), 6.0f);
	vec3 orientationvectori = normalize(cross(cross((Particle1.Position.xyz * discomp) - Particle0.Position.xyz * discomp)), Particle1.Magnitude.xyz), Particle1.Magnitude.xyz)) * barycenterdistance;
	vec3 relativevectori = normalize(Particle0.Position.xyz * discomp) - (Particle1.Position.xyz * discomp) + orientationvectori));
	//float r3decayi = pow((distance(Particle0.Position.xyz * discomp), Particle1.Position.xyz * discomp) + orientationvectori.xyz) + MagneticOffset), 3.0f);
	//vec3 forcedirectioni = normalize(cross(cross(orientationvectori, Particle1.Magnitude.xyz), relativevectori));
	//vec3 totalmagdirectioni = (forcedirectioni * Particle0.Magnitude.w * Particle1.Magnitude.w) / r23decaydiamagnetismi; 
	vec3 totalmagrelativei = ((relativevectori * Particle0.Magnitude.w * Particle1.Magnitude.w) / r23decaydiamagnetismi);
	vec3 forceitoc = totalmagrelativei * (((-acos(dot(Particle0.Magnitude.xyz, Particle1.Magnitude.xyz)) / PI) + 0.5f) * 2);			
	//barycenter of where electrostatic force hits c parrticle from i particle and disperses energy into the lattice. 
	//biased to one side? it seems like 0.5 makes difference between hydrogen and helium less rather then 0.1 hmmm...
	//0.8 is less accurate then 0.5 and 0.1 is less accurate hten 0.5 
	//theoretical predictions say it should be from like 0.5-0.8 on average.
	//vec3 forcecenteritoc = Particle1.Position.xyz * discomp) + ((Particle0.Position.xyz * discomp) - Particle1.Position.xyz * discomp)) * percentoffset);	
	vec3 forcecenteritoc = (Particle1.Position.xyz * discomp) + Particle0.Position.xyz * discomp)) / 2;
	//it can take its own lattice tho ; instead, lattice set originaly to 0. ;
	float aa = 0.0f;
	float lowpointitoc = 0.0f;
	float baselineitoc = distance(forcecenteritoc, Particle0.Position.xyz * discomp));
	for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
	{	
		float e = distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz * discomp)) <= baselineitoc ?
						((1 / pow((distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz * discomp)) / baselineitoc) + MagneticOffset, 6.0f)) * Particles0.ParticlesS[i2].MagnitudeVelocity.w) : 0.0f;	
		//if i2 = c then save how much it adds and then divide that by the total divisor to get the percentage of the force that c has got. ;
		lowpointitoc += e;
		aa = (i2 == c) ? e : aa;
	}
	return ((forceitoc * Particle1.MagnitudeVelocity.w * Particle0.MagnitudeVelocity.w) / lowpointitoc) * (aa / lowpointitoc);
}*/


	/*

		{
	/*
	vec3 relap = normalize(vec3(-totaldiamagp.x, totaldiamagp.y, -totaldiamagp.z));
	mat3 rotp = mat3(
	relap.y, -relap.x, 0,
	relap.x, relap.y, relap.z,
	0,		-relap.z, relap.y
	);
	vec3 irelap = normalize(vec3(totaldiamagp.x, totaldiamagp.y, totaldiamagp.z));
	mat3 irotp = mat3(
	irelap.y, -irelap.x, 0,
	irelap.x, irelap.y, irelap.z,
	0,		 -irelap.z, irelap.y
	);
	vec3 relan = normalize(vec3(-totaldiamagn.x, totaldiamagn.y, -totaldiamagn.z));
	mat3 rotn = mat3(
	relan.y, -relan.x, 0,
	relan.x, relan.y, relan.z,
	0,		-relan.z, relan.y
	);
	vec3 irelan = normalize(vec3(totaldiamagn.x, totaldiamagn.y, totaldiamagn.z));
	mat3 irotn = mat3(
	irelan.y, -irelan.x, 0,
	irelan.x, irelan.y, irelan.z,
	0,		 -irelan.z, irelan.y
	);
	//needs p and n to be transformed to the plane of the subtractor? so then can get the subtraction caps which is y 0 to cap the subtraction,
	//and then subtract transformed n from transformed p or vice versa to get the transform making sure it does violate the caps,
	//and then transform back from plane of subtractor; 
	vec3 totaldiamagtnp = rotn * totaldiamagp;
	vec3 totaldiamagtnn = rotn * totaldiamagn;

	vec3 totaldiamagtpp = rotp * totaldiamagp;
	vec3 totaldiamagtpn = rotp * totaldiamagn;
	//PN DOESNT FUCKING DO ANYTHING ;
	vec3 totaldiamagpn = (length(totaldiamagn) != 0.0f && length(totaldiamagp) != 0.0f ?
						 (irotn * vec3(totaldiamagtnp.x, (sign(totaldiamagtnp.y - totaldiamagtnn.y) == sign(totaldiamagtnp.y) ? (totaldiamagtnp.y - totaldiamagtnn.y) : 0.0f), totaldiamagtnp.z)) : totaldiamagp) +
						 (length(totaldiamagp) != 0.0f && length(totaldiamagn) != 0.0f ?
						 (irotp * vec3(totaldiamagtpn.x, (sign(totaldiamagtpn.y - totaldiamagtpp.y) == sign(totaldiamagtpn.y) ? (totaldiamagtpn.y - totaldiamagtpp.y) : 0.0f), totaldiamagtpn.z)) : totaldiamagn);
	
	}

	

	//iteratively parse all octants in the chunk using the position it came up from  
	//to find the next octant to parse, once all octants are parsed, move up.
	//fix these indexes
	ivec3 next[2][2][2] ={	{{ivec3(1, 0, 0), ivec3(1, 0, 1)},	{ivec3(1, 1, 0),  ivec3(1, 1, 1)}},
							{{ivec3(0, 1, 0),  ivec3(0, 1, 1)},	{ivec3(0, 0, 1),  ivec3(-1, -1, -1)}}};
	
	int CurrentIndex = 0;
	ivec3 Coordinate = ivec3(0);
	while (CurrentIndex != -1)
	{	
		if (distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
					 Particles0.ParticlesS[CurrentIndex].Position.xyz * discomp)) < 0.4 && CurrentIndex != gl_GlobalInvocationID.x)
		{
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = 
				((Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz * Particles0.ParticlesS[CurrentIndex].Position.w)
				* (-clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz * discomp)) - 0.05f, 0.0f, 1.0f) + 1.0f)) 
				+ ((Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)
				* clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz * discomp)), 0.0f, 1.0f));
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
		}
			
		if (distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp),
					 Particles0.ParticlesS[CurrentIndex].Position.xyz * discomp) + Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz) < 0.4 && CurrentIndex != gl_GlobalInvocationID.x)
		{
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = 
				((Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz * Particles0.ParticlesS[CurrentIndex].Position.w)
				* (-clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz * discomp)) - 0.05f, 0.0f, 1.0f) + 1.0f)) 
				+ ((Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)
				* clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz * discomp)), 0.0f, 1.0f));
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
		}
		
		//get octant index from...	
		ivec3 NextChunk = next[Coordinate.x][Coordinate.y][Coordinate.z];
		if (NextChunk == ivec3(-1, -1, -1)) //all octants in this node have been parsed, go up.
		{
			int indextemp = CurrentIndex;
			CurrentIndex = int(Particles0.ParticlesS[CurrentIndex].PositionVelocity.w);

			//get center of particle's chunk.
			float LevelChunkSize0 = (float(PushConstants.Resolution) / pow(2.0f, float(Particles0.ParticlesS[CurrentIndex].level)));
			float ChunkSizeOffset0 = ((LevelChunkSize0 / 2.0f));
			vec3 CurrentChunkPosition = (round((Particles0.ParticlesS[CurrentIndex].Position.xyz * discomp)) / ChunkSizeOffset0) * ChunkSizeOffset0);

			Coordinate = ivec3(clamp(((((Particles0.ParticlesS[indextemp].Position.xyz * discomp)) - (CurrentChun.Position.xyz * discomp))) + 1.0f) / 2), 0.0, 1.0));
			//if parent == -1 then its the root. and end the algorithm.
		}
		else //if not all octants are parsed...
		{	
			//go down if octant has valid data, otherwise stay at current index and increment overload.
			//ignore if chunk doesnt intersect original particle interaction radius.

			float LevelChunkSize0 = (float(PushConstants.Resolution) / pow(2.0f, float(Particles0.ParticlesS[Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z]].level)));
			float ChunkSizeOffset0 = ((LevelChunkSize0 / 2.0f));
			vec3 CurrentChunkPosition = (round((Particles0.ParticlesS[Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z]].Position.xyz * discomp)) / ChunkSizeOffset0) * ChunkSizeOffset0);

			if (Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z] != -1 &&
			OverlapCube((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) - vec3(0.41)), 
						(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) + vec3(0.41)),
						CurrentChun.Position.xyz * discomp) - vec3(LevelChunkSize0 * 8),
						CurrentChun.Position.xyz * discomp) + vec3(LevelChunkSize0 * 8)) == true)
			{ 		
				Coordinate = ivec3(0);
				CurrentIndex = Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z];						
			}
			else 
			{
				Coordinate = ivec3(NextChunk);
			}		
		}

	}*/

				/*
			aa rela is wrong
			vec3 rela = normalize(vec3(-Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.x, Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.y, -Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.z));

			mat3 rot = mat3(
			rela.y, -rela.x, 0,
			rela.x, rela.y, rela.z,
			0,		-rela.z, rela.y
			);

			vec3 relamagA = rot * modmagA;
			vec3 relamagS = rot * modmagS;
			*/
			//vec3 magc = rot * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;
			//vec3 magi = rot * Particles0.ParticlesS[i].Magnitude.xyz;

			//EQUATION OF TRUE NATURE OF ENERGY
			//vec3 xc = (cross((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) - Particles0.ParticlesS[i].Position.xyz * discomp)), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 yc = (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
			//vec3 zc = (cross(cross((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) - Particles0.ParticlesS[i].Position.xyz * discomp)), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));

			//vec3 xi = (cross((Particles0.ParticlesS[i].Position.xyz * discomp) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp)), Particles0.ParticlesS[i].PositionVelocity.xyz));
			//vec3 yi = (Particles0.ParticlesS[i].PositionVelocity.xyz);
			//vec3 zi = (cross(cross((Particles0.ParticlesS[i].Position.xyz * discomp) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp)), Particles0.ParticlesS[i].PositionVelocity.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz));

			//vec3 relativemagc = ((xc * magc.x) + (yc * magc.y) + (zc * magc.z));
			//vec3 relativemagi = ((xi * magi.x) + (yi * magi.y) + (zi * magi.z));
			/*
			velocity and magnitude should both be conserved and be related.

			magnitude is when velocity is cancelled out?? like p - n  ? is that really what magnitude is?? the restoring force to energy cancellation? or the conservation?

			what would magnitude have to be for gravity to work.

			vec3 aaa = Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz - Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz;
			//aaa = zc;

			//the equation doesnt like if position is the same between i and c

			mat3 inv = inverse(mat3(
			xc.x, xc.y, xc.z,
			yc.x, yc.y, yc.z,
			zc.x, zc.y, zc.z));

			aaa = (inv) * aaa;

			vec3 modmagnitude = aaa;
			*/
			//SUBTRACTING THE ENERGY FROM THE MAGNITUDE TO SATISFY CONSERVATION OF ENERGY.
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz -= (modmagnitude) * 0.1;

			//ADDING THE ENERGY TO THE MAGNITUDE ADJUSTED FOR VELOCITY AND DIRECTION.
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += (modmagnitude) * 0.0000001;
		//	Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz);

		
			/*
			//reverse relative to velocity c pls .
			vec3 magaddA = (magi + magc); 

			in situations where magaddA is 0, it doesnt need to transform anyways so its fine;

			vec3 relaA = vec3(-magaddA.x, magaddA.y, -magaddA.z);		
			mat3 rotA = mat3(
			relaA.y, -relaA.x, 0,
			relaA.x, relaA.y, relaA.z,
			0,		-relaA.z, relaA.y
			);
			vec3 rotmagi = rotA * magi;

			vec3 relacA = vec3(-magc.x, magc.y, -magc.z);		
			mat3 rotcA = mat3(
			relacA.y, -relacA.x, 0,
			relacA.x, relacA.y, relacA.z,
			0,		-relacA.z, relacA.y
			);
			vec3 rotmagc = rotcA * magc;

			velc will never be 0 so its fine.;

			vec3 relvelcc = vec3(velc.x, velc.y, velc.z);		
			mat3 rotrelvelcc = mat3(
			relvelcc.y, -relvelcc.x, 0,
			relvelcc.x, relvelcc.y, relvelcc.z,
			0,		-relvelcc.z, relvelcc.y
			);			

			magc might be 0 so figure out what happens. if magc is 0 then transform is in line with velc

			vec3 relmagcc = vec3(magc.x, magc.y, magc.z);	
			mat3 rotrelmagcc = mat3(
			relmagcc.y, -relmagcc.x, 0,
			relmagcc.x, relmagcc.y, relmagcc.z,
			0,		-relmagcc.z, relmagcc.y
			);	

			vec3 modmagA = (rotmagc - rotmagi);

									//THIS IS THE TRANSFORM VECTOR TO SATISFY 3D ENERGY CONSERVATION.
			//vector goes from interacting to current
			//MAKE RELATIVE MAGNITUDEDIFFERENCE!!!! mayby subtract?? 

			vec3 eq = vec3(0, 1, 0) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz; // 0 or 2
			//THSI CAN EITHER BE 2 or -2 IN OPPOSITE MAGNITUDE INT ERACTIONS DEPENDING ON WHAT ONE IS CURREMT, NOT RIGHT. MUST BE RELATIVE!! IE OPPOSITE MUST ALWAYS BE -2
			//1 + 0 when align, -1 + 2 when opposite.
			vec3 addvec = (normalize(normalize(Particles0.ParticlesS[i].Magnitude.xyz) + (-eq)) - normalize(normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz) + (eq)));
			//vec3 addvec = ((Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz) - (Particles0.ParticlesS[i].Magnitude.xyz)) * Particles0.ParticlesS[i].Magnitude.y;
			//vec3 addvec = vec3(0, 1 * (Particles0.ParticlesS[i].Magnitude.y * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.y), 0);

			//this makes it -2 to 0 instead of -2 to 2 for example
			//addvec +=  vec3(0, 1, 0) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;
			addvec += vec3(0, 1, 0);	


			//ADD VECTOR NEEDS TO BE ROTATED IN LINE WITH THE VECTOR OF THE INTERACTING ENERGY;
			//GETTING THE AXISES 
			//if one of the are inverted just flip one of these axis;
			vec3 x = cross((Particles0.ParticlesS[i].Position.xyz * discomp) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp)), Particles0.ParticlesS[i].PositionVelocity.xyz);
			vec3 y = Particles0.ParticlesS[i].PositionVelocity.xyz;
			vec3 z = (Particles0.ParticlesS[i].Position.xyz * discomp) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp)); //z might be wrong

			//ROTATING THE VECTOR
			vec3 modmag = (x * addvec.x) + (y * addvec.y) + (z * addvec.z);


			//does this need?, yes it does, but find out more about magnitude;
			//removing velocity to other particles;
			//mayby this should be before adding??;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += modmag * 0.01; 
			
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz -= Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * 0.01;
	
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);

			//DO GRAVITY WHICH IS POSITIONAL NORMALIZATION AND MAGNITUDE CHANGE.

			//			gravity needs to increase magnitude in z

			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += vec3(0, 0, 0.01);
			/*
			//MAGNITUDE
			ADD MAGNITUDE UNTIL NORMALIZATION (normalization means no potential difference);
			normalization of perpindicular;
			turn magmod into magnitude relative to the current vector;
			try to use an inverse of the axis redefine function;

			vec3 addvec1 = ((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) -
						   (Particles0.ParticlesS[i].Position.xyz * discomp) + Particles0.ParticlesS[i].PositionVelocity.xyz));

			vec3 x1 = cross((Particles0.ParticlesS[i].Position.xyz * discomp) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp)), Particles0.ParticlesS[i].PositionVelocity.xyz);
			vec3 y1 = Particles0.ParticlesS[i].PositionVelocity.xyz;
			vec3 z1 = (Particles0.ParticlesS[i].Position.xyz * discomp) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp)); //z might be wrong

			//vec3 magmod = (x1 * addvec1) + (y1 * addvec1) + (z1 * addvec1);

			JUST GET DISTANCE BETWEEN VECTOR AND AXIS BRO;

			distance(x1, addvec1)

			float x = (x1 * addvec1);
			float y = (y1 * addvec1);
			float z = (z1 * addvec1);


			vec3 finalvec1 = magmod 
			efse;



			remove magnitude too;
			mayby this should be before adding??;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz -= Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += magmod * 0.001; 
			*/

			/*
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (Particles0.ParticlesS[i].PositionVelocity.xyz * (Particles0.ParticlesS[i].Position.w * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w)) * 0.001;
			//REMOVE ENERGY TOO!
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz -= (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) * 0.001;

			//ADD THE GRAVITY. l o l 

			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (Particles0.ParticlesS[i].Position.xyz * discomp) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp)) * 0.001;
			//does it also need to subtract?
			*/
			/*
			vec3 v0 = (Particles0.ParticlesS[i].PositionVelocity.xyz); // * (Particles0.ParticlesS[i].Position.w * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w)
			vec3 v1 = (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);

			vec3 DifferenceV = normalize((Particles0.ParticlesS[i].Position.xyz * discomp) + v0) - (Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz * discomp) + v1));
			vec3 midvector = normalize(cross(v1, v0));

			
			vec3 eee =  normalize(midvector) - normalize(cross(v1, DifferenceV));
			if (length(eee) == 2.0f)
			{
				midvector *= -1.0f;
			}
			
			//this kicks it off deadzones
			//if (length(midvector) != 1.0f)
			{
				//midvector = -normalize(cross(DifferenceV, v1));
			}
			//midvector = -normalize(cross(DifferenceV, v1));
			//vec3 midvector = normalize(cross(DifferenceV, Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 midvector = normalize(cross(cross(cross(DifferenceV, Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 midvector = normalize(cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w, Particles0.ParticlesS[i].PositionVelocity.xyz * Particles0.ParticlesS[i].Position.w));
			
			//if (length(midvector) == 1.0f)
			{


			//float angle = -acos(dot(normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz	* Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w	),
			//						normalize(Particles0.ParticlesS[i].PositionVelocity.xyz							* Particles0.ParticlesS[i].Position.w						)
			//					  )) * 0.00005;
			float angle = 0.005f;
			//float angle = distanceVP * 0.01;

			// Right Hand, Rodrigues' rotation formula:
			//	v = v*cos(t) + (kxv)sin(t) + k*(k.v)(1 - cos(t))
			
			vec3 v = Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz;
			vec3 v1, v2;
			float c = cos(angle);
			float s = sin(angle);
			vec3 k = normalize(midvector);			
			v1 = v*c;
			v2 = cross(k,v);
			v2 = v2*s;
			v1 = v1+v2;
			v2 = k*(dot(k, v) * (1.0f - c));
			v = v1+v2;
			//applying the transform
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = v;
			}
			
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += normalize(differencep) * 0.01;
			

			*/

