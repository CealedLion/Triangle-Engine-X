#version 450
#extension GL_KHR_vulkan_glsl : enable
#define PI 3.141592653589793238462643

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Particle {	
	vec4 Position;
	vec4 PositionVelocity;
	vec4 Magnitude;
	vec4 Acceleration;
	vec4 Special0;
};

layout(std430, set = 0, binding = 0) buffer ParticlesBuffer0 {
	Particle ParticlesS[];
}Particles0;
layout(std430, set = 0, binding = 1) buffer ParticlesBuffer1 {
	Particle ParticlesS[];
}Particles1;

layout (set = 0, binding = 2, r32f) uniform image3D Field0;
layout (set = 0, binding = 3, r32f) uniform image3D Field1;

layout(push_constant) uniform PushConstantsComputeSimplified {
	int Part;
	int Particles;
	int SimulationResolution;
	float Multiplier;
}PushConstants;

//Model constants
float ElectrostaticOffset = 0.432f; //completely arbituary just has to be under 1 and over 0.
float MagneticOffset = 0.99f; //completely arbituary just has to be under 1 and over 0.
float pairingrange = 0.05f; //distance where particles will optimize a electron pair to allow faster simulations.
float percentoffset = 0.5f; //barycenter of where electrostatic force hits c parrticle from i particle and disperses energy into the lattice. //non 0.5 will be unbalanced
float barycenterdistance = 0.000001f; //distance from center of particle where magnetic field starts and particle interior ends.
float MininiumInteractionDistance = 0.01f; //particles under this distance wont be interacted with to prevent infinites. 

float ElectrostaticStrength = 0.35f; //strength of the electostatic interaction.
float DiamagneticStrength = 0.22f;
float MagneticStrength = 3.0f;

vec3 Calculate_Diamagnetism(Particle Particle0, Particle Particle1, int c)
{
	float r23decaydiamagnetismi = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz) + MagneticOffset), 5.0f);
	//electrostatic flux strength determines repulsion strength.
	vec3 forceitoc = abs(Particle1.PositionVelocity.w * Particle0.PositionVelocity.w) * ((normalize(Particle0.Position.xyz - Particle1.Position.xyz)) / r23decaydiamagnetismi);
	//barycenter of where electrostatic force hits c parrticle from i particle and disperses energy into the lattice. 
	//biased to one side? it seems like 0.5 makes difference between hydrogen and helium less rather then 0.1 hmmm...
	//0.8 is less accurate then 0.5 and 0.1 is less accurate hten 0.5 
	//theoretical predictions say it should be from like 0.5-0.8 on average.
	//vec3 forcecenteritoc = Particle1.Position.xyz + ((Particle0.Position.xyz - Particle1.Position.xyz) * percentoffset);	
	vec3 forcecenteritoc = (Particle1.Position.xyz + Particle0.Position.xyz) / 2;	
	//it can take its own lattice tho ; instead, lattice set originaly to 0. ;
	float lowpointitoc = 0.0f;
	float baselineitoc = distance(forcecenteritoc, Particle0.Position.xyz);
	for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
	{	
		lowpointitoc += distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) <= baselineitoc ?
						((1 / pow((distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) / baselineitoc) + MagneticOffset, 5.0f)) * Particles0.ParticlesS[i2].Acceleration.x * Particles0.ParticlesS[i2].Magnitude.w) : 0.0f;		
	}
	//the check makes it unbalanced;
	return (forceitoc * Particle1.Acceleration.x * Particle0.Acceleration.x) / lowpointitoc;	
}
vec3 Calculate_LatticeDiamagnetism(Particle Particle0, Particle Particle1, int c)
{
	float r23decaydiamagnetismi = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz) + MagneticOffset), 5.0f);
	//electrostatic flux strength determines repulsion strength.
	vec3 forceitoc = abs(Particle1.PositionVelocity.w * Particle0.PositionVelocity.w) * ((normalize(Particle0.Position.xyz - Particle1.Position.xyz)) / r23decaydiamagnetismi);			
	//barycenter of where electrostatic force hits c parrticle from i particle and disperses energy into the lattice. 
	//biased to one side? it seems like 0.5 makes difference between hydrogen and helium less rather then 0.1 hmmm...
	//0.8 is less accurate then 0.5 and 0.1 is less accurate hten 0.5 
	//theoretical predictions say it should be from like 0.5-0.8 on average.
	//vec3 forcecenteritoc = Particle1.Position.xyz + ((Particle0.Position.xyz - Particle1.Position.xyz) * percentoffset);	
	vec3 forcecenteritoc = (Particle1.Position.xyz + Particle0.Position.xyz) / 2;
	//it can take its own lattice tho ; instead, lattice set originaly to 0. ;
	float aa = 0.0f;
	float lowpointitoc = 0.0f;
	float baselineitoc = distance(forcecenteritoc, Particle0.Position.xyz);
	for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
	{	
		float e = distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) <= baselineitoc ?
						((1 / pow((distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) / baselineitoc) + MagneticOffset, 5.0f)) * Particles0.ParticlesS[i2].Acceleration.x * Particles0.ParticlesS[i2].Magnitude.w) : 0.0f;	
		//if i2 = c then save how much it adds and then divide that by the total divisor to get the percentage of the force that c has got. ;
		lowpointitoc += e;
		aa = (i2 == c) ? e : aa;
	}
	//the check makes it unbalanced;
	return lowpointitoc != 0.0f ? (forceitoc * Particle1.Acceleration.x * Particle0.Acceleration.x) * (aa / lowpointitoc) : vec3(0);
}


vec3 Calculate_Magnetism(Particle Particle0, Particle Particle1, int c)
{
	//either way it sseems like strong magnetic fields are out of the question, ;
	//waittttttt what about magnetism from velocity/orbital velocity and spin ;
	//so that would make particles closer to nucleus have stronger magnetism. 
	//its just justified r5 or r6;

	float r23decaydiamagnetismi = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz) + MagneticOffset), 6.0f);
	vec3 orientationvectori = normalize(cross(cross((Particle1.Position.xyz - Particle0.Position.xyz), Particle1.Magnitude.xyz), Particle1.Magnitude.xyz)) * barycenterdistance;
	vec3 relativevectori = normalize(Particle0.Position.xyz - (Particle1.Position.xyz + orientationvectori));
	//float r3decayi = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz + orientationvectori.xyz) + MagneticOffset), 3.0f);
	//vec3 forcedirectioni = normalize(cross(cross(orientationvectori, Particle1.Magnitude.xyz), relativevectori));
	//vec3 totalmagdirectioni = (forcedirectioni * Particle0.Magnitude.w * Particle1.Magnitude.w) / r23decaydiamagnetismi; 
	vec3 totalmagrelativei = ((relativevectori * Particle0.Magnitude.w * Particle1.Magnitude.w) / r23decaydiamagnetismi);

	vec3 forceitoc = totalmagrelativei * (((-acos(dot(Particle0.Magnitude.xyz, Particle1.Magnitude.xyz)) / PI) + 0.5f) * 2);
	
	//vec3 forceitoc = abs(Particle1.PositionVelocity.w * Particle0.PositionVelocity.w) * ((normalize(Particle0.Position.xyz - Particle1.Position.xyz)) / r23decaydiamagnetismi);
	//barycenter of where electrostatic force hits c parrticle from i particle and disperses energy into the lattice. 
	//biased to one side? it seems like 0.5 makes difference between hydrogen and helium less rather then 0.1 hmmm...
	//0.8 is less accurate then 0.5 and 0.1 is less accurate hten 0.5 
	//theoretical predictions say it should be from like 0.5-0.8 on average.
	//vec3 forcecenteritoc = Particle1.Position.xyz + ((Particle0.Position.xyz - Particle1.Position.xyz) * percentoffset);	
	vec3 forcecenteritoc = (Particle1.Position.xyz + Particle0.Position.xyz) / 2;	
	//it can take its own lattice tho ; instead, lattice set originaly to 0. ;
	float lowpointitoc = 0.0f;
	float baselineitoc = distance(forcecenteritoc, Particle0.Position.xyz);
	for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
	{	
		lowpointitoc += distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) <= baselineitoc ?
						((1 / pow((distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) / baselineitoc) + MagneticOffset, 6.0f)) * Particles0.ParticlesS[i2].Acceleration.x * Particles0.ParticlesS[i2].Magnitude.w) : 0.0f;		
	}
	//the check makes it unbalanced;
	return (forceitoc * Particle1.Acceleration.x * Particle0.Acceleration.x) / lowpointitoc;	
}
vec3 Calculate_LatticeMagnetism(Particle Particle0, Particle Particle1, int c)
{
	float r23decaydiamagnetismi = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz) + MagneticOffset), 6.0f);
	vec3 orientationvectori = normalize(cross(cross((Particle1.Position.xyz - Particle0.Position.xyz), Particle1.Magnitude.xyz), Particle1.Magnitude.xyz)) * barycenterdistance;
	vec3 relativevectori = normalize(Particle0.Position.xyz - (Particle1.Position.xyz + orientationvectori));
	//float r3decayi = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz + orientationvectori.xyz) + MagneticOffset), 3.0f);
	//vec3 forcedirectioni = normalize(cross(cross(orientationvectori, Particle1.Magnitude.xyz), relativevectori));
	//vec3 totalmagdirectioni = (forcedirectioni * Particle0.Magnitude.w * Particle1.Magnitude.w) / r23decaydiamagnetismi; 
	vec3 totalmagrelativei = ((relativevectori * Particle0.Magnitude.w * Particle1.Magnitude.w) / r23decaydiamagnetismi);

	vec3 forceitoc = totalmagrelativei * (((-acos(dot(Particle0.Magnitude.xyz, Particle1.Magnitude.xyz)) / PI) + 0.5f) * 2);
			
	//barycenter of where electrostatic force hits c parrticle from i particle and disperses energy into the lattice. 
	//biased to one side? it seems like 0.5 makes difference between hydrogen and helium less rather then 0.1 hmmm...
	//0.8 is less accurate then 0.5 and 0.1 is less accurate hten 0.5 
	//theoretical predictions say it should be from like 0.5-0.8 on average.
	//vec3 forcecenteritoc = Particle1.Position.xyz + ((Particle0.Position.xyz - Particle1.Position.xyz) * percentoffset);	
	vec3 forcecenteritoc = (Particle1.Position.xyz + Particle0.Position.xyz) / 2;
	//it can take its own lattice tho ; instead, lattice set originaly to 0. ;
	float aa = 0.0f;
	float lowpointitoc = 0.0f;
	float baselineitoc = distance(forcecenteritoc, Particle0.Position.xyz);
	for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
	{	
		float e = distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) <= baselineitoc ?
						((1 / pow((distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) / baselineitoc) + MagneticOffset, 6.0f)) * Particles0.ParticlesS[i2].Acceleration.x * Particles0.ParticlesS[i2].Magnitude.w) : 0.0f;	
		//if i2 = c then save how much it adds and then divide that by the total divisor to get the percentage of the force that c has got. ;
		lowpointitoc += e;
		aa = (i2 == c) ? e : aa;
	}
	//the check makes it unbalanced;
	return lowpointitoc != 0.0f ? (forceitoc * Particle1.Acceleration.x * Particle0.Acceleration.x) * (aa / lowpointitoc) : vec3(0);
}

void main(void)
{
	if (PushConstants.Part == 0)
	{
	Particles0.ParticlesS[gl_GlobalInvocationID.x] = Particles1.ParticlesS[gl_GlobalInvocationID.x];
	}
	else if (PushConstants.Part == 1)
	{	
	/*
	TODO:

	proper thermodynamic regulation force that makes the simulation at a set temperature. 
	proper pressure simulation and container simulation
	
	magnetic drag isnt relative but oh well none of it is. so make it all relative;

	magnetism from orbital velocity

	v2 momemtum add ? 

	why is boron the only pairing anomaly or is element 20 one too? seems like those elements have pairing anomalies. 

	lorentz transformation
	1 / (1 / sqrt(1 -  (pow(v, 2) / pow(c, 2))))
	cos(arcsin(v / c)) 
	*/	

	float pairedparticleindex = -1.0f;
	float closestnucleusindex = -1.0f;
	float closestnucleusdistance = 999999999999.0f;

	vec3 totalpos = vec3(0.0f);
	vec3 totalrot = vec3(0.0f);

	vec3 totalmagdirectioni = vec3(0.0f);
	vec3 totalmagrelativei = vec3(0.0f);

	//vec3 totaldiamagp = vec3(0.0f);
	//vec3 totaldiamagn = vec3(0.0f);

	float chargec = Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.w;
	float massc = Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w;
	float spinc = Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w;

	//magnetic
	vec3 totalmag = (Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w);
	for (int i = 0; i < PushConstants.Particles; i++) 
	{	
		if (gl_GlobalInvocationID.x != i)
		{	
			float chargei = Particles0.ParticlesS[i].PositionVelocity.w;		
			float massi = Particles0.ParticlesS[i].Position.w;		
			float spini = Particles0.ParticlesS[i].Magnitude.w;		
			float disci = distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz);
			float r3decay = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz) + MagneticOffset), 3.0f);
	
			totalmag += ((Particles0.ParticlesS[i].Magnitude.xyz * Particles0.ParticlesS[i].Magnitude.w) / r3decay) * pow(MagneticOffset, 3.0f);	
			//if interacting particle and current particle are electrons and they are close enough, they pair. is exclusive.
			pairedparticleindex = (disci < pairingrange && spini != 0.0f && spinc != 0.0f) ? i : pairedparticleindex;	
			
			closestnucleusindex = (disci < closestnucleusdistance && spini == 0.0f && spinc != 0.0f) ? i : closestnucleusindex;	
			closestnucleusdistance = (disci < closestnucleusdistance && spini == 0.0f && spinc != 0.0f) ? disci : closestnucleusdistance;	

			if (disci > MininiumInteractionDistance)
			{
			//electrostatic flux strength determines repulsion strength.
			//totaldiamagp += ((chargec * chargei) > 0.0f) ? Particles0.ParticlesS[i].Acceleration.x * abs(chargec * chargei) * ((normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz)) / r3decay) : vec3(0);
			//totaldiamagn += ((chargec * chargei) < 0.0f) ? Particles0.ParticlesS[i].Acceleration.x * abs(chargec * chargei) * ((normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz)) / r3decay) : vec3(0);
			}
		}
	}
	//figure out how this scales. in terms of geometry ; its only used iin calculating total mag lattice so far. i think it is geometrical. so do that
	//total mag should be 0.5 if canceled out and 1 if not.;
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x = clamp(length(totalmag), 0.5f, 1.0f);
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.y = pairedparticleindex;		
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z = closestnucleusindex;
	{
	/*
	vec3 relap = normalize(vec3(-totaldiamagp.x, totaldiamagp.y, -totaldiamagp.z));
	mat3 rotp = mat3(
	relap.y, -relap.x, 0,
	relap.x, relap.y, relap.z,
	0,		-relap.z, relap.y
	);
	vec3 irelap = normalize(vec3(totaldiamagp.x, totaldiamagp.y, totaldiamagp.z));
	mat3 irotp = mat3(
	irelap.y, -irelap.x, 0,
	irelap.x, irelap.y, irelap.z,
	0,		 -irelap.z, irelap.y
	);
	vec3 relan = normalize(vec3(-totaldiamagn.x, totaldiamagn.y, -totaldiamagn.z));
	mat3 rotn = mat3(
	relan.y, -relan.x, 0,
	relan.x, relan.y, relan.z,
	0,		-relan.z, relan.y
	);
	vec3 irelan = normalize(vec3(totaldiamagn.x, totaldiamagn.y, totaldiamagn.z));
	mat3 irotn = mat3(
	irelan.y, -irelan.x, 0,
	irelan.x, irelan.y, irelan.z,
	0,		 -irelan.z, irelan.y
	);
	//needs p and n to be transformed to the plane of the subtractor? so then can get the subtraction caps which is y 0 to cap the subtraction,
	//and then subtract transformed n from transformed p or vice versa to get the transform making sure it does violate the caps,
	//and then transform back from plane of subtractor; 
	vec3 totaldiamagtnp = rotn * totaldiamagp;
	vec3 totaldiamagtnn = rotn * totaldiamagn;

	vec3 totaldiamagtpp = rotp * totaldiamagp;
	vec3 totaldiamagtpn = rotp * totaldiamagn;
	//PN DOESNT FUCKING DO ANYTHING ;
	vec3 totaldiamagpn = (length(totaldiamagn) != 0.0f && length(totaldiamagp) != 0.0f ?
						 (irotn * vec3(totaldiamagtnp.x, (sign(totaldiamagtnp.y - totaldiamagtnn.y) == sign(totaldiamagtnp.y) ? (totaldiamagtnp.y - totaldiamagtnn.y) : 0.0f), totaldiamagtnp.z)) : totaldiamagp) +
						 (length(totaldiamagp) != 0.0f && length(totaldiamagn) != 0.0f ?
						 (irotp * vec3(totaldiamagtpn.x, (sign(totaldiamagtpn.y - totaldiamagtpp.y) == sign(totaldiamagtpn.y) ? (totaldiamagtpn.y - totaldiamagtpp.y) : 0.0f), totaldiamagtpn.z)) : totaldiamagn);
	*/
	}
	for (int i = 0; i < PushConstants.Particles; i++) 
	{	
		if (gl_GlobalInvocationID.x != i)
		{	
			float chargei = Particles0.ParticlesS[i].PositionVelocity.w;		
			float massi = Particles0.ParticlesS[i].Position.w;		
			float spini = Particles0.ParticlesS[i].Magnitude.w;		
			//mayby also make a deadzone that is the shape of the inner field?;		
			float disci = distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz);
			float r2decayci = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz) + ElectrostaticOffset), 2.0f);	
			//scale magneticorientationvector to set distance of magnetic field. 	
			vec3 orientationvectori = normalize(cross(cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].Magnitude.xyz), Particles0.ParticlesS[i].Magnitude.xyz)) * barycenterdistance;
			//vec3 orientationvectorc = normalize(cross(cross((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz)) * barycenterdistance;
			//vector between field center and particle
			vec3 relativevectori = normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - (Particles0.ParticlesS[i].Position.xyz + orientationvectori));
			//vec3 relativevectorc = normalize(Particles0.ParticlesS[i].Position.xyz - (Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + orientationvectorc));
			//how compressed a given degree of the field is due to the particle obstruction. 
			//float fieldcompressionfactori = (acos(dot(normalize(orientationvectori), relativevectori)) / PI);
			//float fieldcompressionfactorc = (acos(dot(normalize(orientationvectorc), relativevectorc)) / PI);
			//distance decays 
			//float forcestrengh = ((1.0f / fieldcompressionfactor) / pow(length((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - (Particles0.ParticlesS[i].Position.xyz + orientationvector))), 3.0f / fieldcompressionfactor));
			float r3decayi = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz + orientationvectori.xyz) + MagneticOffset), 3.0f);
			//float r3decayc = pow((distance(Particles0.ParticlesS[i].Position.xyz, Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + orientationvectorc.xyz) + offset), 3.0f);
			//now find direction of it
			vec3 forcedirectioni = normalize(cross(cross(orientationvectori, Particles0.ParticlesS[i].Magnitude.xyz), relativevectori));
			//vec3 forcedirectionc = normalize(cross(cross(orientationvectorc, Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), relativevectorc));
			//oh fuck we forgot magnetism from orbital velocity;
			//vec3 forcedirectionfromvelocity = cross(Particles0.ParticlesS[i].PositionVelocity.xyz, );
			if (disci > MininiumInteractionDistance)  
			{ 
			/*
			closer electrons should get more of energy absorbed by nucleus when closer when interacting with their mirrored counterpart. 
			which would reduce diamagnetism on the particle and make it sink more, which is desirable right. 
			so r2 decay from i to i2? so further the diamagnetism stealing particle is the less it takes? 
			*/ 
			{
			vec3 Diamagnetismitoc = Calculate_Diamagnetism(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i], int(gl_GlobalInvocationID.x));
			vec3 Diamagnetismlattice = vec3(0.0f);
			for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
			{	
				if (gl_GlobalInvocationID.x != i2 && i != i2)
				{	
					float disci2 = distance(Particles0.ParticlesS[i].Position.xyz, Particles0.ParticlesS[i2].Position.xyz);
					if (disci2 > MininiumInteractionDistance) 
					{
					Diamagnetismlattice += Calculate_LatticeDiamagnetism(Particles0.ParticlesS[i], Particles0.ParticlesS[i2], int(gl_GlobalInvocationID.x));
					}
				}
			}		
			totalpos += Diamagnetismlattice * DiamagneticStrength;		
			totalpos += Diamagnetismitoc * DiamagneticStrength;		
			}
			//magnetism probably have lattice interactions so make that, should be similar system to diamagnetism. ;
			//it would reduce cross nucleur magnetism and make it better 

			{
			vec3 Magnetismitoc = Calculate_Magnetism(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i], int(gl_GlobalInvocationID.x));
			vec3 Magnetismlattice = vec3(0.0f);
			for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
			{	
				if (gl_GlobalInvocationID.x != i2 && i != i2)
				{	
					float disci2 = distance(Particles0.ParticlesS[i].Position.xyz, Particles0.ParticlesS[i2].Position.xyz);
					if (disci2 > MininiumInteractionDistance) 
					{
					Magnetismlattice += Calculate_LatticeMagnetism(Particles0.ParticlesS[i], Particles0.ParticlesS[i2], int(gl_GlobalInvocationID.x));
					}
				}
			}		
			totalpos += Magnetismlattice * MagneticStrength;		
			totalpos += Magnetismitoc * MagneticStrength;		
			}
			//totalpos += length(totalmagdirectioni) != 0.0f ? totalmagrelativei * (((-acos(dot(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz,Particles0.ParticlesS[i].Magnitude.xyz)) / PI) + 0.5f) * 2) * MagnetismPositionalStrength : vec3(0.0f);


			//option a, special case magnetism, self centering. ;
			//so basicially the closer a particle is to a nucleus the more of its magnetism is centered. 
			//it shouldnt add more magnitude then what was already present ; so normalize it by relativevectori ;
			//float decayr3np = pow(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[int(Particles0.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z)].Position.xyz) + MagneticOffset, 3.0f);
			//vec3 nuclearpolarization = normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[int(Particles0.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z)].Position.xyz) / decayr3np;
			//the percentage of relative vector that becomes aligned with nucleus depends on how close it is. r3 or r2;
			//btw this is only the case if there is a paired particle aligned oppisite on the other side of nucleus. symmetrically. so include that.;
			//relativevectori = Particles0.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z != -1 ? 
			//			 ((nuclearpolarization + relativevectori) * (length(relativevectori) / length((nuclearpolarization + relativevectori)))) : relativevectori;
			//because if c doesnt have net spin then can it really even be affected by magnetism. 
			//totalmagdirectioni = (forcedirectioni * spini * spinc * Particles0.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x * Particles0.ParticlesS[i].Acceleration.x) / r3decayi; 
			//totalmagrelativei = (relativevectori * spini * spinc * Particles0.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x * Particles0.ParticlesS[i].Acceleration.x) / r3decayi;

			//so ughhhhhhhhhhhhhhhhhhhhhhhhhhh WHATS THE ORIGIN OF PAIRING?;
			//pairing under pressure probably idk ;
			//its probabbly a combination of a lot of factors. 
			//you can indeed arrange magnitudes of electrons so they dont affect structure.  

			//magneitc polorizatiabiity has to be fine, so that oxygen and nitrogen arew both fine.
			//totalrot += (totalmagdirectioni * -((((-acos(dot(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, normalize(totalmagdirectioni))) / PI) + 0.5f) * 2) + 0.5f)) * 0.1f;
			//totalrot += totalmagdirectioni * 0.1f;
			//totalrot += cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, totalmagdirectioni) * 0.0001f;

			//normal force (electrostatic)
			totalpos += (chargec * chargei) * (normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz) / r2decayci) * ElectrostaticStrength;
			//perpindicular (light)
			//a particle accelerated in direction x signicantly enough it releases perpindicular energy that induces motion in particles in direction -x.;
			//also when a particles magnetic field is hit it creates a copy of the impacting wave.;
			//needs to follow dominant frequency theory too;
			//totalpos += ((chargec * chargei) * ((length(Particles1.ParticlesS[i].Acceleration.xyz) > Threshold) ? (-Particles1.ParticlesS[i].Acceleration.xyz / r2decay) : vec3(0.0f))) * 0.1f;
			//gravity force (irrelevent on this scale)
			//totalpos += ((1.0 / 404331557902116024553602703216.58) / distancesqaured) * pParticle2->Size; // ((0.00000000001) / distancesqaured) * pParticle2->Size
			}
		}
	}
	//Magnetic Particle Circular Motion In Magnetic Field Transform.
	//totalpos += cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz, totalmagdirectioni) * 0.000001f;
	//Magnetic Positional Transform
	//oscillation is caused by magnetism. magnetism is retarded, due to normalization, its kind of too janky, but is there really better approximation?;
	//totalpos += length(totalmagdirectioni) != 0.0f ? totalmagrelativei * (((-acos(dot(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, normalize(totalmagdirectioni))) / PI) + 0.5f) * 2) * MagnetismPositionalStrength : vec3(0.0f);
	//Magnetic Drag Positional Transform
	//totalpos += (length(totalmagdirectioni) * -(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)) * 0.0000001f;
	
	//Magnetic Particle Precession Motion In Magnetic Field Transform.
	//rate of precession, theres an equilibrium where the amount of energy deflected by precession = total force exerted;
	//the combined forced should be a combination of this making it precess, and the other one making it normalize;
	//calculating the strength of the precession relative to the normalization is extremely difficult.;
	//totalrot += cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, totalmagdirectioni) * 0.000001f;
	//Magnetic Particle Alignment Transform.
	//totalrot += (totalmagdirectioni * -((((-acos(dot(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, normalize(totalmagdirectioni))) / PI) + 0.5f) * 2) + 0.5f)) * 0.0000001f;

	//temp checks
	totalpos = length(totalpos) > 0.0f ? totalpos : vec3(0);
	totalpos = length(totalpos) < 10000.0f ? totalpos : vec3(0);
	totalrot = length(totalrot) > 0.0f ? totalrot : vec3(0);
	totalrot = length(totalrot) < 10000.0f ? totalrot : vec3(0);

	//final addition
	Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (totalpos / massc) * (PushConstants.Multiplier * 0.001);
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += (totalrot / massc) * (PushConstants.Multiplier * 0.001);
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz);

	//temporary slowdown effect
	if (length(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) > 0.0001f)
	{
		float bleedm = 0.01f * PushConstants.Multiplier;
		float bleed = 1.0f - bleedm;
		Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * bleed;
	} 
	/*//container 
	if (length(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) > 10.0f)
	{
		Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (normalize(-Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) * 0.00001f) * PushConstants.Multiplier;
	}*/
	//if paired it will add positions together to get average position.
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz = pairedparticleindex != -1 ?
		((Particles0.ParticlesS[int(pairedparticleindex)].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) / 2) : Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz;
	//if paired it will add position velocity with paired particle to get combined force.
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz += ((pairedparticleindex != -1 ?
		((Particles0.ParticlesS[int(pairedparticleindex)].PositionVelocity.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) / 2) : Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz
		) * 0.01f) * PushConstants.Multiplier;
	}
}


	/*
	//iteratively parse all octants in the chunk using the position it came up from  
	//to find the next octant to parse, once all octants are parsed, move up.
	//fix these indexes
	ivec3 next[2][2][2] ={	{{ivec3(1, 0, 0), ivec3(1, 0, 1)},	{ivec3(1, 1, 0),  ivec3(1, 1, 1)}},
							{{ivec3(0, 1, 0),  ivec3(0, 1, 1)},	{ivec3(0, 0, 1),  ivec3(-1, -1, -1)}}};
	
	int CurrentIndex = 0;
	ivec3 Coordinate = ivec3(0);
	while (CurrentIndex != -1)
	{	
		if (distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
					 Particles0.ParticlesS[CurrentIndex].Position.xyz) < 0.4 && CurrentIndex != gl_GlobalInvocationID.x)
		{
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = 
				((Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz * Particles0.ParticlesS[CurrentIndex].Position.w)
				* (-clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz) - 0.05f, 0.0f, 1.0f) + 1.0f)) 
				+ ((Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)
				* clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz), 0.0f, 1.0f));
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
		}
			
		if (distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz,
					 Particles0.ParticlesS[CurrentIndex].Position.xyz + Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz) < 0.4 && CurrentIndex != gl_GlobalInvocationID.x)
		{
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = 
				((Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz * Particles0.ParticlesS[CurrentIndex].Position.w)
				* (-clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz) - 0.05f, 0.0f, 1.0f) + 1.0f)) 
				+ ((Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)
				* clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz), 0.0f, 1.0f));
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
		}
		
		//get octant index from...	
		ivec3 NextChunk = next[Coordinate.x][Coordinate.y][Coordinate.z];
		if (NextChunk == ivec3(-1, -1, -1)) //all octants in this node have been parsed, go up.
		{
			int indextemp = CurrentIndex;
			CurrentIndex = int(Particles0.ParticlesS[CurrentIndex].PositionVelocity.w);

			//get center of particle's chunk.
			float LevelChunkSize0 = (float(PushConstants.Resolution) / pow(2.0f, float(Particles0.ParticlesS[CurrentIndex].level)));
			float ChunkSizeOffset0 = ((LevelChunkSize0 / 2.0f));
			vec3 CurrentChunkPosition = (round((Particles0.ParticlesS[CurrentIndex].Position.xyz) / ChunkSizeOffset0) * ChunkSizeOffset0);

			Coordinate = ivec3(clamp(((((Particles0.ParticlesS[indextemp].Position.xyz) - (CurrentChunkPosition.xyz)) + 1.0f) / 2), 0.0, 1.0));
			//if parent == -1 then its the root. and end the algorithm.
		}
		else //if not all octants are parsed...
		{	
			//go down if octant has valid data, otherwise stay at current index and increment overload.
			//ignore if chunk doesnt intersect original particle interaction radius.

			float LevelChunkSize0 = (float(PushConstants.Resolution) / pow(2.0f, float(Particles0.ParticlesS[Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z]].level)));
			float ChunkSizeOffset0 = ((LevelChunkSize0 / 2.0f));
			vec3 CurrentChunkPosition = (round((Particles0.ParticlesS[Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z]].Position.xyz) / ChunkSizeOffset0) * ChunkSizeOffset0);

			if (Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z] != -1 &&
			OverlapCube((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - vec3(0.41)), 
						(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + vec3(0.41)),
						CurrentChunkPosition.xyz - vec3(LevelChunkSize0 * 8),
						CurrentChunkPosition.xyz + vec3(LevelChunkSize0 * 8)) == true)
			{ 		
				Coordinate = ivec3(0);
				CurrentIndex = Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z];						
			}
			else 
			{
				Coordinate = ivec3(NextChunk);
			}		
		}

	}*/

				/*
			aa rela is wrong
			vec3 rela = normalize(vec3(-Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.x, Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.y, -Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.z));

			mat3 rot = mat3(
			rela.y, -rela.x, 0,
			rela.x, rela.y, rela.z,
			0,		-rela.z, rela.y
			);

			vec3 relamagA = rot * modmagA;
			vec3 relamagS = rot * modmagS;
			*/
			//vec3 magc = rot * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;
			//vec3 magi = rot * Particles0.ParticlesS[i].Magnitude.xyz;

			//EQUATION OF TRUE NATURE OF ENERGY
			//vec3 xc = (cross((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 yc = (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
			//vec3 zc = (cross(cross((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));

			//vec3 xi = (cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz));
			//vec3 yi = (Particles0.ParticlesS[i].PositionVelocity.xyz);
			//vec3 zi = (cross(cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz));

			//vec3 relativemagc = ((xc * magc.x) + (yc * magc.y) + (zc * magc.z));
			//vec3 relativemagi = ((xi * magi.x) + (yi * magi.y) + (zi * magi.z));
			/*
			velocity and magnitude should both be conserved and be related.

			magnitude is when velocity is cancelled out?? like p - n  ? is that really what magnitude is?? the restoring force to energy cancellation? or the conservation?

			what would magnitude have to be for gravity to work.

			vec3 aaa = Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz - Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz;
			//aaa = zc;

			//the equation doesnt like if position is the same between i and c

			mat3 inv = inverse(mat3(
			xc.x, xc.y, xc.z,
			yc.x, yc.y, yc.z,
			zc.x, zc.y, zc.z));

			aaa = (inv) * aaa;

			vec3 modmagnitude = aaa;
			*/
			//SUBTRACTING THE ENERGY FROM THE MAGNITUDE TO SATISFY CONSERVATION OF ENERGY.
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz -= (modmagnitude) * 0.1;

			//ADDING THE ENERGY TO THE MAGNITUDE ADJUSTED FOR VELOCITY AND DIRECTION.
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += (modmagnitude) * 0.0000001;
		//	Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz);

		
			/*
			//reverse relative to velocity c pls .
			vec3 magaddA = (magi + magc); 

			in situations where magaddA is 0, it doesnt need to transform anyways so its fine;

			vec3 relaA = vec3(-magaddA.x, magaddA.y, -magaddA.z);		
			mat3 rotA = mat3(
			relaA.y, -relaA.x, 0,
			relaA.x, relaA.y, relaA.z,
			0,		-relaA.z, relaA.y
			);
			vec3 rotmagi = rotA * magi;

			vec3 relacA = vec3(-magc.x, magc.y, -magc.z);		
			mat3 rotcA = mat3(
			relacA.y, -relacA.x, 0,
			relacA.x, relacA.y, relacA.z,
			0,		-relacA.z, relacA.y
			);
			vec3 rotmagc = rotcA * magc;

			velc will never be 0 so its fine.;

			vec3 relvelcc = vec3(velc.x, velc.y, velc.z);		
			mat3 rotrelvelcc = mat3(
			relvelcc.y, -relvelcc.x, 0,
			relvelcc.x, relvelcc.y, relvelcc.z,
			0,		-relvelcc.z, relvelcc.y
			);			

			magc might be 0 so figure out what happens. if magc is 0 then transform is in line with velc

			vec3 relmagcc = vec3(magc.x, magc.y, magc.z);	
			mat3 rotrelmagcc = mat3(
			relmagcc.y, -relmagcc.x, 0,
			relmagcc.x, relmagcc.y, relmagcc.z,
			0,		-relmagcc.z, relmagcc.y
			);	

			vec3 modmagA = (rotmagc - rotmagi);

									//THIS IS THE TRANSFORM VECTOR TO SATISFY 3D ENERGY CONSERVATION.
			//vector goes from interacting to current
			//MAKE RELATIVE MAGNITUDEDIFFERENCE!!!! mayby subtract?? 

			vec3 eq = vec3(0, 1, 0) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz; // 0 or 2
			//THSI CAN EITHER BE 2 or -2 IN OPPOSITE MAGNITUDE INT ERACTIONS DEPENDING ON WHAT ONE IS CURREMT, NOT RIGHT. MUST BE RELATIVE!! IE OPPOSITE MUST ALWAYS BE -2
			//1 + 0 when align, -1 + 2 when opposite.
			vec3 addvec = (normalize(normalize(Particles0.ParticlesS[i].Magnitude.xyz) + (-eq)) - normalize(normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz) + (eq)));
			//vec3 addvec = ((Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz) - (Particles0.ParticlesS[i].Magnitude.xyz)) * Particles0.ParticlesS[i].Magnitude.y;
			//vec3 addvec = vec3(0, 1 * (Particles0.ParticlesS[i].Magnitude.y * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.y), 0);

			//this makes it -2 to 0 instead of -2 to 2 for example
			//addvec +=  vec3(0, 1, 0) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;
			addvec += vec3(0, 1, 0);	


			//ADD VECTOR NEEDS TO BE ROTATED IN LINE WITH THE VECTOR OF THE INTERACTING ENERGY;
			//GETTING THE AXISES 
			//if one of the are inverted just flip one of these axis;
			vec3 x = cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz);
			vec3 y = Particles0.ParticlesS[i].PositionVelocity.xyz;
			vec3 z = (Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz); //z might be wrong

			//ROTATING THE VECTOR
			vec3 modmag = (x * addvec.x) + (y * addvec.y) + (z * addvec.z);


			//does this need?, yes it does, but find out more about magnitude;
			//removing velocity to other particles;
			//mayby this should be before adding??;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += modmag * 0.01; 
			
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz -= Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * 0.01;
	
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);

			//DO GRAVITY WHICH IS POSITIONAL NORMALIZATION AND MAGNITUDE CHANGE.

			//			gravity needs to increase magnitude in z

			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += vec3(0, 0, 0.01);
			/*
			//MAGNITUDE
			ADD MAGNITUDE UNTIL NORMALIZATION (normalization means no potential difference);
			normalization of perpindicular;
			turn magmod into magnitude relative to the current vector;
			try to use an inverse of the axis redefine function;

			vec3 addvec1 = ((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) -
						   (Particles0.ParticlesS[i].Position.xyz + Particles0.ParticlesS[i].PositionVelocity.xyz));

			vec3 x1 = cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz);
			vec3 y1 = Particles0.ParticlesS[i].PositionVelocity.xyz;
			vec3 z1 = (Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz); //z might be wrong

			//vec3 magmod = (x1 * addvec1) + (y1 * addvec1) + (z1 * addvec1);

			JUST GET DISTANCE BETWEEN VECTOR AND AXIS BRO;

			distance(x1, addvec1)

			float x = (x1 * addvec1);
			float y = (y1 * addvec1);
			float z = (z1 * addvec1);


			vec3 finalvec1 = magmod 
			efse;



			remove magnitude too;
			mayby this should be before adding??;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz -= Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += magmod * 0.001; 
			*/

			/*
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (Particles0.ParticlesS[i].PositionVelocity.xyz * (Particles0.ParticlesS[i].Position.w * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w)) * 0.001;
			//REMOVE ENERGY TOO!
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz -= (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) * 0.001;

			//ADD THE GRAVITY. l o l 

			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) * 0.001;
			//does it also need to subtract?
			*/
			/*
			vec3 v0 = (Particles0.ParticlesS[i].PositionVelocity.xyz); // * (Particles0.ParticlesS[i].Position.w * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w)
			vec3 v1 = (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);

			vec3 DifferenceV = normalize((Particles0.ParticlesS[i].Position.xyz + v0) - (Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + v1));
			vec3 midvector = normalize(cross(v1, v0));

			
			vec3 eee =  normalize(midvector) - normalize(cross(v1, DifferenceV));
			if (length(eee) == 2.0f)
			{
				midvector *= -1.0f;
			}
			
			//this kicks it off deadzones
			//if (length(midvector) != 1.0f)
			{
				//midvector = -normalize(cross(DifferenceV, v1));
			}
			//midvector = -normalize(cross(DifferenceV, v1));
			//vec3 midvector = normalize(cross(DifferenceV, Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 midvector = normalize(cross(cross(cross(DifferenceV, Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 midvector = normalize(cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w, Particles0.ParticlesS[i].PositionVelocity.xyz * Particles0.ParticlesS[i].Position.w));
			
			//if (length(midvector) == 1.0f)
			{


			//float angle = -acos(dot(normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz	* Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w	),
			//						normalize(Particles0.ParticlesS[i].PositionVelocity.xyz							* Particles0.ParticlesS[i].Position.w						)
			//					  )) * 0.00005;
			float angle = 0.005f;
			//float angle = distanceVP * 0.01;

			// Right Hand, Rodrigues' rotation formula:
			//	v = v*cos(t) + (kxv)sin(t) + k*(k.v)(1 - cos(t))
			
			vec3 v = Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz;
			vec3 v1, v2;
			float c = cos(angle);
			float s = sin(angle);
			vec3 k = normalize(midvector);			
			v1 = v*c;
			v2 = cross(k,v);
			v2 = v2*s;
			v1 = v1+v2;
			v2 = k*(dot(k, v) * (1.0f - c));
			v = v1+v2;
			//applying the transform
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = v;
			}
			
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += normalize(differencep) * 0.01;
			

			*/

