#version 450
#extension GL_KHR_vulkan_glsl : enable
#define PI 3.141592653589793238462643

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Particle {	
	vec4 Position;
	vec4 PositionVelocity;
	vec4 Magnitude;
	vec4 Acceleration;
	//int Info0[2][2][2];
	//int level;
};

layout(std430, set = 0, binding = 0) buffer ParticlesBuffer0 {
	Particle ParticlesS[];
}Particles0;
layout(std430, set = 0, binding = 1) buffer ParticlesBuffer1 {
	Particle ParticlesS[];
}Particles1;

layout (set = 0, binding = 2, r32f) uniform image3D Field0;
layout (set = 0, binding = 3, r32f) uniform image3D Field1;

layout(push_constant) uniform PushConstantsComputeSimplified {
	int Part;
	int Particles;
	int SimulationResolution;
	float Multiplier;
}PushConstants;

bool CubePointIntersect(vec3 c0p0, vec3 c0p1, vec3 p1)
{
	return (c0p1.x > p1.x &&
			c0p0.x < p1.x &&
			c0p1.y > p1.y && 
			c0p0.y < p1.y &&
			c0p1.z > p1.z &&
			c0p0.z < p1.z);
}

vec3 rotate (vec3 v, vec3 n, float a) {
	return v * cos(a) + cross(n, v) * sin(a) + n * dot(n, v) * (1. - cos(a));
}

void main(void)
{
	if (PushConstants.Part == 0)
	{
	Particles0.ParticlesS[gl_GlobalInvocationID.x] = Particles1.ParticlesS[gl_GlobalInvocationID.x];
	}
	else if (PushConstants.Part == 1)
	{	
	/*
	TODO:

	proper thermodynamic regulation force that makes the simulation at a set temperature. 
	proper pressure simulation and container simulation
	
	magnetic drag isnt relative but oh well none of it is. so make it all relative;

	magnetism from orbital velocity

	lorentz transformation
	1 / (1 / sqrt(1 -  (pow(v, 2) / pow(c, 2))))
	cos(arcsin(v / c)) 
	*/	
	//1. mayby a geometric system where distances directly calculate the radius of the magnetic field? 
	//get half of the distance between i and c, thats the magnetic field influence radius between those 2 particles, 
	//then average all them out. then use that final value and 1 / cubicroot(x) to get final effective diamagnetic cross sectionx
	//calculating extent of the magnetic field	
	//ugh but larger magnetic fields then become less strong as they get larger its not exactly right but idk  
	//the calculating average density just needs to be mroe accurate 1 / pow(x, 3) is just temporary 
	//totalmagstrengthc =  PI * pow(totalmagstrengthc, 2) * (1 / pow(totalmagstrengthc, 3));
	//slightly less decay means that its closer to average but this is just temporary
	//hmm the problem with lithium seems to be geometrical, afterall this is just a multipication by cross section but that might nto be correct in this situation
	//effective cross section should increase with distance 
	//its just lithium thats wrong, boron is fine, so 1 electron is wrong 
	/*
	HERE: 

	vector to get barycenter of where the diamangeitc energy is hitting and use w as the magnitude of the impacts 
	
	which we can then get r2 decay from it? from i to c
	
	and then we need to divide the force somehow . . .  just divide it i gues we already know its right bro 
	*/
	float offset = 1.00f;
	float pairingrange = 0.05f;
	int pairedparticleindex = -1;

	vec3 totalpos = vec3(0.0f);
	vec3 totalrot = vec3(0.0f);

	vec3 totalmagdirectioni = vec3(0.0f);
	vec3 totalmagrelativei = vec3(0.0f);

	vec3 totaldiamagp = vec3(0.0f);
	vec3 totaldiamagn = vec3(0.0f);

	vec3 totaldiamagsrcp = vec3(0.0f);
	vec3 totaldiamagsrcn = vec3(0.0f);

	float chargec = Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.w;
	float massc = Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w;
	float spinc = Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w;
	//lattice 
	float totalmaglattice = 1.0f;
	float dividebyp = 0;
	float dividebyn = 0;
	float divideby = 0;

	float totalmagstrengthc = 1.0f;
	vec3 magbarycenter = vec3(0.0f);
	//vec3 totalmag = (Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w);
	for (int i = 0; i < PushConstants.Particles; i++) 
	{	
		if (gl_GlobalInvocationID.x != i)
		{	
			float chargei = Particles0.ParticlesS[i].PositionVelocity.w;		
			float massi = Particles0.ParticlesS[i].Position.w;		
			float spini = Particles0.ParticlesS[i].Magnitude.w;		
			float disci = distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz);
			float r3decay2 = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz) + offset), 3.0f);

			//totalmag += ((Particles0.ParticlesS[i].Magnitude.xyz * Particles0.ParticlesS[i].Magnitude.w) * (dot(Particles0.ParticlesS[i].Magnitude.xyz, Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz) > 0.0f ? 0.0f : 1.0f)) / r3decay2;		
			//if interacting particle and current particle are electrons and they are close enough, they pair. is exclusive.
			pairedparticleindex = ((disci < pairingrange) ? (spini != 0.0f ? (spinc != 0.0f ? i : pairedparticleindex) : pairedparticleindex) : pairedparticleindex);			 
			if (disci > 0.01f)
			{
			float r23decaydiamagnetismi = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz) + offset), 3.0f);
			//electrostatic flux strength determines repulsion strength.
			totaldiamagp += ((chargec * chargei) > 0.0f) ? (chargec * chargei) * ((normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz)) / r23decaydiamagnetismi) : vec3(0);
			totaldiamagn += ((chargec * chargei) < 0.0f) ? -(chargec * chargei) * ((normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz)) / r23decaydiamagnetismi) : vec3(0);

			//electrostatic flux strength determines repulsion strength.
			//totaldiamagp += ((chargec * chargei) > 0.0f) ? (chargec * chargei) * ((normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz)) / r23decaydiamagnetismi) : vec3(0);
			//totaldiamagn += ((chargec * chargei) < 0.0f) ? -(chargec * chargei) * ((normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz)) / r23decaydiamagnetismi) : vec3(0);
			//divisor scales depending on how much force it adds, from 0-1 1 being full force, its related to component 
			//basicially just get totaldiamagp and compare to this and use that same equation to calculate component
			//fix barycenter calculation;
			vec3 diamagsrcp = ((chargec * chargei) > 0.0f) ? ((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz)) : vec3(0);
			vec3 diamagsrcn = ((chargec * chargei) < 0.0f) ? ((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz)) : vec3(0);
			//so alignment means it just gets cancelled out and has no effect, so the addition needs to get larger as it gets closer to perpindicular and then down again. 
			//divideby += ((chargec * chargei) > 0.0f) ? (-abs(dot(totaldiamagn, diamagsrcp)) + 1.0f) : 0.0f;
			//divideby += ((chargec * chargei) < 0.0f) ? (-abs(dot(diamagsrcn, totaldiamagp)) + 1.0f) : 0.0f;
			dividebyp += ((chargec * chargei) > 0.0f) ? 1 : (0);
			dividebyn += ((chargec * chargei) < 0.0f) ? 1 : (0);
			divideby += 1;

			totaldiamagsrcp += diamagsrcp;
			totaldiamagsrcn += diamagsrcn;
			}
		}
	}
	//totalmag = (pairedparticleindex != -1 ? 0.0f : 1.0f) * totalmag;
	//float totalmagstrength = clamp(length(totalmag), 0.0f, 1.0f);
	totalmagstrengthc = (pairedparticleindex != -1 ? 0.0f : 1.0f * spinc);
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x = totalmagstrengthc;

	magbarycenter.xyz = (totaldiamagsrcn + totaldiamagsrcp) / (divideby != 0.0f ?  divideby : 1.0f);

	for (int i = 0; i < PushConstants.Particles; i++) 
	{	
		if (gl_GlobalInvocationID.x != i)
		{	
			float chargei = Particles0.ParticlesS[i].PositionVelocity.w;		
			float massi = Particles0.ParticlesS[i].Position.w;		
			float spini = Particles0.ParticlesS[i].Magnitude.w;		
			//mayby also make a deadzone that is the shape of the inner field?;		
			float barycenterdistance = 0.000001f;
			float disci = distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz);
			float r2decayci = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz) + offset), 2.0f);	
			//scale magneticorientationvector to set distance of magnetic field. 	
			vec3 orientationvectori = normalize(cross(cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].Magnitude.xyz), Particles0.ParticlesS[i].Magnitude.xyz)) * barycenterdistance;
			vec3 orientationvectorc = normalize(cross(cross((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz)) * barycenterdistance;
			//vector between field center and particle
			vec3 relativevectori = normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - (Particles0.ParticlesS[i].Position.xyz + orientationvectori));
			vec3 relativevectorc = normalize(Particles0.ParticlesS[i].Position.xyz - (Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + orientationvectorc));
			//how compressed a given degree of the field is due to the particle obstruction. 
			//float fieldcompressionfactori = (acos(dot(normalize(orientationvectori), relativevectori)) / PI);
			//float fieldcompressionfactorc = (acos(dot(normalize(orientationvectorc), relativevectorc)) / PI);
			//distance decays 
			//float forcestrengh = ((1.0f / fieldcompressionfactor) / pow(length((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - (Particles0.ParticlesS[i].Position.xyz + orientationvector))), 3.0f / fieldcompressionfactor));
			float r3decayi = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz + orientationvectori.xyz) + offset), 3.0f);
			float r3decayc = pow((distance(Particles0.ParticlesS[i].Position.xyz, Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + orientationvectorc.xyz) + offset), 3.0f);
			//now find direction of it
			vec3 forcedirectioni = normalize(cross(cross(orientationvectori, Particles0.ParticlesS[i].Magnitude.xyz), relativevectori));
			vec3 forcedirectionc = normalize(cross(cross(orientationvectorc, Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), relativevectorc));
			//oh fuck we forgot magnetism from orbital velocity;
			//vec3 forcedirectionfromvelocity = cross(Particles0.ParticlesS[i].PositionVelocity.xyz, );
			float r3decay2 = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz) + offset), 3.0f);

			//this is the amount of lattice connection. 
			//basicially, calculate diamagnetism force barycenter position of c, distance from c position to this barycenter is the baseline/normalization distance for 
			//the distance decay between barycenter and i particle position. 
			float discbarycenter = distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + magbarycenter.xyz);
			float disibarycenter = distance(Particles0.ParticlesS[i].Position.xyz, Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + magbarycenter.xyz);
			//hmmm it seems to make it lose diamagnetism when getting closer? which means barycenter isnt correct 
			//the nucleus shouldnt  divide its own diamagnetism;
		//	it seems like totalmagstrength for paired is near 0, because the paired particle cancels out but then other particles add to it. .. .;
			//is a strong force that keeps electrons in a sphere desired? 
			aaa;
			totalmaglattice += (Particles0.ParticlesS[i].Acceleration.x) / 1;
			//totalmaglattice += (totalmagstrength) / (disibarycenter / discbarycenter);

			//totalmag += (Particles0.ParticlesS[i].Magnitude.xyz * Particles0.ParticlesS[i].Magnitude.w) / r3decay2;
			if (disci > 0.01f)
			{
			//NEW DIAMAGNETISM METHOD PROGRAM IT MORE SIMILAR TO OLD SYSTEM BUT DIFFERENT STILL;
			//different in that its caused by electrostatic; 
			//diamagnetism varies from r2 to r3 decay depending on how large the extent of the magnetic field is. ;		
			//does it really decay r3 once it gets to magnetic field? probably. 	 
			//float discioffset = (disci + offset);
			//float r23decaydiamagnetismi = pow(min(max(discioffset - (dynamicoffset), offset), discioffset), 2.0f);
			//r23decaydiamagnetismi = r23decaydiamagnetismi * pow(min(max(discioffset - (disci - dynamicoffset), offset), discioffset), 3.0f);
			float r23decaydiamagnetismi = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz) + offset), 3.0f);

			totalmagdirectioni += ((forcedirectioni * spini) / r3decayi); 
			totalmagrelativei += ((relativevectori * spini) / r3decayi);

			//normal force (electrostatic)
			totalpos += (chargec * chargei) * (normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz) / r2decayci) * 0.1f;
			//perpindicular (light)
			//a particle accelerated in direction x signicantly enough it releases perpindicular energy that induces motion in particles in direction -x.;
			//also when a particle's magnetic field is hit it creates a copy of the impacting wave.;
			//needs to follow dominant frequency theory too;
			//totalpos += ((chargec * chargei) * ((length(Particles1.ParticlesS[i].Acceleration.xyz) > Threshold) ? (-Particles1.ParticlesS[i].Acceleration.xyz / r2decay) : vec3(0.0f))) * 0.1f;
			//gravity force (irrelevent on this scale)
			//totalpos += ((1.0 / 404331557902116024553602703216.58) / distancesqaured) * pParticle2->Size; // ((0.00000000001) / distancesqaured) * pParticle2->Size
			}
		}
	}
	//we need divide by for each 
	//totaldiamagsrcp = dividebyp != 0.0f ? (totaldiamagsrcp / dividebyp) : vec3(0.0f);
	//totaldiamagsrcn = dividebyn != 0.0f ? (totaldiamagsrcn / dividebyn) : vec3(0.0f);
	//gets percentage of the total electrostatic energy that is of 1 energy type, and uses that to calculate real diamagnetism transform since different energy types cancel out their diamangetic effect when combined, and then multiplies it by the total diamagnetic transform. 
	//the closer the diamagnetism p and n magnitudes the more it cancels out the total diamagnetic force.
	totalpos += ((((totaldiamagn - (totaldiamagp * dot(totaldiamagn, totaldiamagp))) + (totaldiamagp - (totaldiamagn * dot(totaldiamagn, totaldiamagp)))) * totalmagstrengthc) / totalmaglattice) * 1.5f;

	
	//Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.xyz = ((totaldiamagsrcn - (totaldiamagsrcp * dot(totaldiamagsrcn, totaldiamagsrcp))) + (totaldiamagsrcp - (totaldiamagsrcn * dot(totaldiamagsrcn, totaldiamagsrcp))));

	//Magnetic Particle Circular Motion In Magnetic Field Transform.
	//totalpos += cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz, totalmagdirectioni) * 0.000001f;
	//Magnetic Positional Transform
	//totalpos += totalmagrelativei * (((-acos(dot(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, normalize(totalmagdirectioni))) / PI) + 0.5f) * 2) * 0.01f;
	//Magnetic Drag Positional Transform
	//totalpos += (length(totalmagdirectioni) * -(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)) * 0.0000001f;
	//Magnetic Particle Precession Motion In Magnetic Field Transform.
	//rate of precession, theres an equilibrium where the amount of energy deflected by precession = total force exerted;
	//the combined forced should be a combination of this making it precess, and the other one making it normalize;
	//calculating the strength of the precession relative to the normalization is extremely difficult.;
	//totalrot += cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, totalmagdirectioni) * 0.000001f;
	//Magnetic Particle Alignment Transform.
	//totalrot += (totalmagdirectioni * -((((-acos(dot(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, normalize(totalmagdirectioni))) / PI) + 0.5f) * 2) + 0.5f)) * 0.0000001f;

	//temp checks
	totalpos = length(totalpos) > 0.0f ? totalpos : vec3(0);
	totalpos = length(totalpos) < 100000.0f ? totalpos : vec3(0);
	totalrot = length(totalrot) > 0.0f ? totalrot : vec3(0);
	totalrot = length(totalrot) < 100000.0f ? totalrot : vec3(0);

	//final addition
	Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (totalpos / massc) * (PushConstants.Multiplier * 0.01);
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += (totalrot / massc) * (PushConstants.Multiplier * 0.01);
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz);

	//temporary slowdown effect
	if (length(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) > 0.0001f)
	{
		float bleedm = 0.01f * PushConstants.Multiplier;
		float bleed = 1.0f - bleedm;
		Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * bleed;
	} 
	/*//container 
	if (length(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) > 10.0f)
	{
		Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (normalize(-Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) * 0.00001f) * PushConstants.Multiplier;
	}*/
	//if paired it will add positions together to get average position.
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz = pairedparticleindex != -1 ?
		((Particles0.ParticlesS[pairedparticleindex].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) / 2) : Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz;
	//if paired it will add position velocity with paired particle to get combined force.
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz += ((pairedparticleindex != -1 ?
		((Particles0.ParticlesS[pairedparticleindex].PositionVelocity.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) / 2) : Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz
		) * 0.01f) * PushConstants.Multiplier;
	}
}


	/*
	//iteratively parse all octants in the chunk using the position it came up from  
	//to find the next octant to parse, once all octants are parsed, move up.
	//fix these indexes
	ivec3 next[2][2][2] ={	{{ivec3(1, 0, 0), ivec3(1, 0, 1)},	{ivec3(1, 1, 0),  ivec3(1, 1, 1)}},
							{{ivec3(0, 1, 0),  ivec3(0, 1, 1)},	{ivec3(0, 0, 1),  ivec3(-1, -1, -1)}}};
	
	int CurrentIndex = 0;
	ivec3 Coordinate = ivec3(0);
	while (CurrentIndex != -1)
	{	
		if (distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
					 Particles0.ParticlesS[CurrentIndex].Position.xyz) < 0.4 && CurrentIndex != gl_GlobalInvocationID.x)
		{
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = 
				((Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz * Particles0.ParticlesS[CurrentIndex].Position.w)
				* (-clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz) - 0.05f, 0.0f, 1.0f) + 1.0f)) 
				+ ((Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)
				* clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz), 0.0f, 1.0f));
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
		}
			
		if (distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz,
					 Particles0.ParticlesS[CurrentIndex].Position.xyz + Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz) < 0.4 && CurrentIndex != gl_GlobalInvocationID.x)
		{
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = 
				((Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz * Particles0.ParticlesS[CurrentIndex].Position.w)
				* (-clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz) - 0.05f, 0.0f, 1.0f) + 1.0f)) 
				+ ((Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)
				* clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz), 0.0f, 1.0f));
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
		}
		
		//get octant index from...	
		ivec3 NextChunk = next[Coordinate.x][Coordinate.y][Coordinate.z];
		if (NextChunk == ivec3(-1, -1, -1)) //all octants in this node have been parsed, go up.
		{
			int indextemp = CurrentIndex;
			CurrentIndex = int(Particles0.ParticlesS[CurrentIndex].PositionVelocity.w);

			//get center of particle's chunk.
			float LevelChunkSize0 = (float(PushConstants.Resolution) / pow(2.0f, float(Particles0.ParticlesS[CurrentIndex].level)));
			float ChunkSizeOffset0 = ((LevelChunkSize0 / 2.0f));
			vec3 CurrentChunkPosition = (round((Particles0.ParticlesS[CurrentIndex].Position.xyz) / ChunkSizeOffset0) * ChunkSizeOffset0);

			Coordinate = ivec3(clamp(((((Particles0.ParticlesS[indextemp].Position.xyz) - (CurrentChunkPosition.xyz)) + 1.0f) / 2), 0.0, 1.0));
			//if parent == -1 then its the root. and end the algorithm.
		}
		else //if not all octants are parsed...
		{	
			//go down if octant has valid data, otherwise stay at current index and increment overload.
			//ignore if chunk doesnt intersect original particle interaction radius.

			float LevelChunkSize0 = (float(PushConstants.Resolution) / pow(2.0f, float(Particles0.ParticlesS[Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z]].level)));
			float ChunkSizeOffset0 = ((LevelChunkSize0 / 2.0f));
			vec3 CurrentChunkPosition = (round((Particles0.ParticlesS[Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z]].Position.xyz) / ChunkSizeOffset0) * ChunkSizeOffset0);

			if (Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z] != -1 &&
			OverlapCube((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - vec3(0.41)), 
						(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + vec3(0.41)),
						CurrentChunkPosition.xyz - vec3(LevelChunkSize0 * 8),
						CurrentChunkPosition.xyz + vec3(LevelChunkSize0 * 8)) == true)
			{ 		
				Coordinate = ivec3(0);
				CurrentIndex = Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z];						
			}
			else 
			{
				Coordinate = ivec3(NextChunk);
			}		
		}

	}*/

				/*
			aa rela is wrong
			vec3 rela = normalize(vec3(-Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.x, Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.y, -Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.z));

			mat3 rot = mat3(
			rela.y, -rela.x, 0,
			rela.x, rela.y, rela.z,
			0,		-rela.z, rela.y
			);

			vec3 relamagA = rot * modmagA;
			vec3 relamagS = rot * modmagS;
			*/
			//vec3 magc = rot * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;
			//vec3 magi = rot * Particles0.ParticlesS[i].Magnitude.xyz;

			//EQUATION OF TRUE NATURE OF ENERGY
			//vec3 xc = (cross((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 yc = (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
			//vec3 zc = (cross(cross((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));

			//vec3 xi = (cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz));
			//vec3 yi = (Particles0.ParticlesS[i].PositionVelocity.xyz);
			//vec3 zi = (cross(cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz));

			//vec3 relativemagc = ((xc * magc.x) + (yc * magc.y) + (zc * magc.z));
			//vec3 relativemagi = ((xi * magi.x) + (yi * magi.y) + (zi * magi.z));
			/*
			velocity and magnitude should both be conserved and be related.

			magnitude is when velocity is cancelled out?? like p - n  ? is that really what magnitude is?? the restoring force to energy cancellation? or the conservation?

			what would magnitude have to be for gravity to work.

			vec3 aaa = Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz - Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz;
			//aaa = zc;

			//the equation doesnt like if position is the same between i and c

			mat3 inv = inverse(mat3(
			xc.x, xc.y, xc.z,
			yc.x, yc.y, yc.z,
			zc.x, zc.y, zc.z));

			aaa = (inv) * aaa;

			vec3 modmagnitude = aaa;
			*/
			//SUBTRACTING THE ENERGY FROM THE MAGNITUDE TO SATISFY CONSERVATION OF ENERGY.
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz -= (modmagnitude) * 0.1;

			//ADDING THE ENERGY TO THE MAGNITUDE ADJUSTED FOR VELOCITY AND DIRECTION.
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += (modmagnitude) * 0.0000001;
		//	Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz);

		
			/*
			//reverse relative to velocity c pls .
			vec3 magaddA = (magi + magc); 

			in situations where magaddA is 0, it doesnt need to transform anyways so its fine;

			vec3 relaA = vec3(-magaddA.x, magaddA.y, -magaddA.z);		
			mat3 rotA = mat3(
			relaA.y, -relaA.x, 0,
			relaA.x, relaA.y, relaA.z,
			0,		-relaA.z, relaA.y
			);
			vec3 rotmagi = rotA * magi;

			vec3 relacA = vec3(-magc.x, magc.y, -magc.z);		
			mat3 rotcA = mat3(
			relacA.y, -relacA.x, 0,
			relacA.x, relacA.y, relacA.z,
			0,		-relacA.z, relacA.y
			);
			vec3 rotmagc = rotcA * magc;

			velc will never be 0 so its fine.;

			vec3 relvelcc = vec3(velc.x, velc.y, velc.z);		
			mat3 rotrelvelcc = mat3(
			relvelcc.y, -relvelcc.x, 0,
			relvelcc.x, relvelcc.y, relvelcc.z,
			0,		-relvelcc.z, relvelcc.y
			);			

			magc might be 0 so figure out what happens. if magc is 0 then transform is in line with velc

			vec3 relmagcc = vec3(magc.x, magc.y, magc.z);	
			mat3 rotrelmagcc = mat3(
			relmagcc.y, -relmagcc.x, 0,
			relmagcc.x, relmagcc.y, relmagcc.z,
			0,		-relmagcc.z, relmagcc.y
			);	

			vec3 modmagA = (rotmagc - rotmagi);

									//THIS IS THE TRANSFORM VECTOR TO SATISFY 3D ENERGY CONSERVATION.
			//vector goes from interacting to current
			//MAKE RELATIVE MAGNITUDEDIFFERENCE!!!! mayby subtract?? 

			vec3 eq = vec3(0, 1, 0) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz; // 0 or 2
			//THSI CAN EITHER BE 2 or -2 IN OPPOSITE MAGNITUDE INT ERACTIONS DEPENDING ON WHAT ONE IS CURREMT, NOT RIGHT. MUST BE RELATIVE!! IE OPPOSITE MUST ALWAYS BE -2
			//1 + 0 when align, -1 + 2 when opposite.
			vec3 addvec = (normalize(normalize(Particles0.ParticlesS[i].Magnitude.xyz) + (-eq)) - normalize(normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz) + (eq)));
			//vec3 addvec = ((Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz) - (Particles0.ParticlesS[i].Magnitude.xyz)) * Particles0.ParticlesS[i].Magnitude.y;
			//vec3 addvec = vec3(0, 1 * (Particles0.ParticlesS[i].Magnitude.y * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.y), 0);

			//this makes it -2 to 0 instead of -2 to 2 for example
			//addvec +=  vec3(0, 1, 0) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;
			addvec += vec3(0, 1, 0);	


			//ADD VECTOR NEEDS TO BE ROTATED IN LINE WITH THE VECTOR OF THE INTERACTING ENERGY;
			//GETTING THE AXISES 
			//if one of the are inverted just flip one of these axis;
			vec3 x = cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz);
			vec3 y = Particles0.ParticlesS[i].PositionVelocity.xyz;
			vec3 z = (Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz); //z might be wrong

			//ROTATING THE VECTOR
			vec3 modmag = (x * addvec.x) + (y * addvec.y) + (z * addvec.z);


			//does this need?, yes it does, but find out more about magnitude;
			//removing velocity to other particles;
			//mayby this should be before adding??;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += modmag * 0.01; 
			
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz -= Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * 0.01;
	
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);

			//DO GRAVITY WHICH IS POSITIONAL NORMALIZATION AND MAGNITUDE CHANGE.

			//			gravity needs to increase magnitude in z

			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += vec3(0, 0, 0.01);
			/*
			//MAGNITUDE
			ADD MAGNITUDE UNTIL NORMALIZATION (normalization means no potential difference);
			normalization of perpindicular;
			turn magmod into magnitude relative to the current vector;
			try to use an inverse of the axis redefine function;

			vec3 addvec1 = ((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) -
						   (Particles0.ParticlesS[i].Position.xyz + Particles0.ParticlesS[i].PositionVelocity.xyz));

			vec3 x1 = cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz);
			vec3 y1 = Particles0.ParticlesS[i].PositionVelocity.xyz;
			vec3 z1 = (Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz); //z might be wrong

			//vec3 magmod = (x1 * addvec1) + (y1 * addvec1) + (z1 * addvec1);

			JUST GET DISTANCE BETWEEN VECTOR AND AXIS BRO;

			distance(x1, addvec1)

			float x = (x1 * addvec1);
			float y = (y1 * addvec1);
			float z = (z1 * addvec1);


			vec3 finalvec1 = magmod 
			efse;



			remove magnitude too;
			mayby this should be before adding??;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz -= Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += magmod * 0.001; 
			*/

			/*
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (Particles0.ParticlesS[i].PositionVelocity.xyz * (Particles0.ParticlesS[i].Position.w * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w)) * 0.001;
			//REMOVE ENERGY TOO!
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz -= (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) * 0.001;

			//ADD THE GRAVITY. l o l 

			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) * 0.001;
			//does it also need to subtract?
			*/
			/*
			vec3 v0 = (Particles0.ParticlesS[i].PositionVelocity.xyz); // * (Particles0.ParticlesS[i].Position.w * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w)
			vec3 v1 = (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);

			vec3 DifferenceV = normalize((Particles0.ParticlesS[i].Position.xyz + v0) - (Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + v1));
			vec3 midvector = normalize(cross(v1, v0));

			
			vec3 eee =  normalize(midvector) - normalize(cross(v1, DifferenceV));
			if (length(eee) == 2.0f)
			{
				midvector *= -1.0f;
			}
			
			//this kicks it off deadzones
			//if (length(midvector) != 1.0f)
			{
				//midvector = -normalize(cross(DifferenceV, v1));
			}
			//midvector = -normalize(cross(DifferenceV, v1));
			//vec3 midvector = normalize(cross(DifferenceV, Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 midvector = normalize(cross(cross(cross(DifferenceV, Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 midvector = normalize(cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w, Particles0.ParticlesS[i].PositionVelocity.xyz * Particles0.ParticlesS[i].Position.w));
			
			//if (length(midvector) == 1.0f)
			{


			//float angle = -acos(dot(normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz	* Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w	),
			//						normalize(Particles0.ParticlesS[i].PositionVelocity.xyz							* Particles0.ParticlesS[i].Position.w						)
			//					  )) * 0.00005;
			float angle = 0.005f;
			//float angle = distanceVP * 0.01;

			// Right Hand, Rodrigues' rotation formula:
			//	v = v*cos(t) + (kxv)sin(t) + k*(k.v)(1 - cos(t))
			
			vec3 v = Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz;
			vec3 v1, v2;
			float c = cos(angle);
			float s = sin(angle);
			vec3 k = normalize(midvector);			
			v1 = v*c;
			v2 = cross(k,v);
			v2 = v2*s;
			v1 = v1+v2;
			v2 = k*(dot(k, v) * (1.0f - c));
			v = v1+v2;
			//applying the transform
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = v;
			}
			
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += normalize(differencep) * 0.01;
			

			*/

