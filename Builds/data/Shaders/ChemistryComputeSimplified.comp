#version 450
#extension GL_KHR_vulkan_glsl : enable
#define PI 3.141592653589793238462643

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct Particle {	
	vec4 Position;
	vec4 PositionVelocity;
	vec4 Magnitude;
	vec4 MagnitudeVelocity;
	vec4 Acceleration;
};

layout(std430, set = 0, binding = 0) buffer ParticlesBuffer0 {
	Particle ParticlesS[];
}Particles0;
layout(std430, set = 0, binding = 1) buffer ParticlesBuffer1 {
	Particle ParticlesS[];
}Particles1;

layout(push_constant) uniform PushConstantsComputeSimplified {
	int Part;
	int Particles;
	float Multiplier;

	float ElectrostaticOffset;
	float DiamagneticOffset;
	float MagneticOffset;

	float ElectrostaticStrength;
	float DiamagneticStrength;
	float MagneticStrength;

	float ElectrostaticAlignmentStrength;
	float DiamagneticAlignmentStrength;
	float MagneticAlignmentStrength;

	float maxpairing;
	float exponent;

}PushConstants;

//Model Settings
float MininiumInteractionDistance = 0.05f; //particles under this distance wont be interacted with to prevent infinites. 
float pairingrange = 0.00001f; //distance where particles will optimize a electron pair to allow faster simulations.
float barycenterdistance = 0.01f; //distance from center of particle where magnetic field starts and particle interior ends.

//need to find out if there is a definitive value for any of these constants ;
//3 of them the offsets and electrostatic strength migth have definitive,
//use machine learning to solve the rest 
//but first make sure model is really accurate. ;

vec3 rotate (vec3 v, vec3 n, float a) {
	return v * cos(a) + cross(n, v) * sin(a) + n * dot(n, v) * (1. - cos(a));
}

struct calcreturn {
	vec3 pos;
	vec3 rot;
};
calcreturn Calculate_Electrostatic(Particle Particle0, Particle Particle1)
{
	calcreturn ret;
	//Normal Emission Force (electrostatic)
	float r2decay = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz) + PushConstants.ElectrostaticOffset), 2.0f);	
	vec3 relativevector = normalize(Particle0.Position.xyz - Particle1.Position.xyz);
	ret.pos = (((Particle0.PositionVelocity.w * Particle1.PositionVelocity.w) * relativevector) / r2decay) * 0.01f;
	//electrostatic wouldnt induce rotations because particles are too small and on magnetic it is diamagneitsm.
	ret.rot = vec3(0.0f);
	return ret;	
}
calcreturn Calculate_Magnetism(Particle Particle0, Particle Particle1)
{
	calcreturn ret;		
	vec3 relativevector = normalize(Particle0.Position.xyz - Particle1.Position.xyz);
	vec3 polecp = Particle0.Position.xyz +  (Particle0.Magnitude.xyz * barycenterdistance) + ( relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 polecn = Particle0.Position.xyz + -(Particle0.Magnitude.xyz * barycenterdistance) + ( relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 poleip = Particle1.Position.xyz +  (Particle1.Magnitude.xyz * barycenterdistance) + (-relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 polein = Particle1.Position.xyz + -(Particle1.Magnitude.xyz * barycenterdistance) + (-relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 polepforce = vec3(0.0f);
	polepforce += (( relativevector * Particle0.Magnitude.w * Particle1.Magnitude.w) / (4 * PI * pow(distance(polecp, poleip) + PushConstants.MagneticOffset, 2.0f)));
	polepforce += ((-relativevector * Particle0.Magnitude.w * Particle1.Magnitude.w) / (4 * PI * pow(distance(polecp, polein) + PushConstants.MagneticOffset, 2.0f)));
	vec3 polenforce = vec3(0.0f);
	polenforce += (( relativevector * Particle0.Magnitude.w * Particle1.Magnitude.w) / (4 * PI * pow(distance(polecn, polein) + PushConstants.MagneticOffset, 2.0f)));
	polenforce += ((-relativevector * Particle0.Magnitude.w * Particle1.Magnitude.w) / (4 * PI * pow(distance(polecn, poleip) + PushConstants.MagneticOffset, 2.0f)));
	ret.pos = (polepforce + polenforce);
//	rotation needs to use precession theory too
	//Magnetic Particle Precession Motion In Magnetic Field Transform.
	//rate of precession, theres an equilibrium where the amount of energy deflected by precession = total force exerted;
	//the combined forced should be a combination of this making it precess, and the other one making it normalize;
	//calculating the strength of the precession relative to the normalization is extremely difficult.;
	//totalrot += cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, totalmagdirectioni) * 0.000001f;
	//i think each pole having a torque moment and the more force exerted the more rotation? ;
	//mayby just add position transform onto rot?? and then rotate to magnitude plane? 
	ret.rot = (polepforce - polenforce);
	return ret;	
}
calcreturn Calculate_Diamagnetism(Particle Particle0, Particle Particle1)
{
	calcreturn ret; 
	//magnetism from orbital velocity this might explain why van der waals is r6 because diamagnetism is only r5;
	vec3 relativevector = normalize(Particle0.Position.xyz - Particle1.Position.xyz);

	//magnetic part 
	float tot = 0.0f;
	{
	vec3 polecp = Particle0.Position.xyz +  (-Particle0.Magnitude.xyz * barycenterdistance) + ( relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 polecn = Particle0.Position.xyz + -(-Particle0.Magnitude.xyz * barycenterdistance) + ( relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 poleip = Particle1.Position.xyz +  (-Particle0.Magnitude.xyz * barycenterdistance) + (-relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 polein = Particle1.Position.xyz + -(-Particle0.Magnitude.xyz * barycenterdistance) + (-relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 polepforce = vec3(0.0f);
	polepforce += (( relativevector * Particle0.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecp, poleip) + PushConstants.MagneticOffset, 2.0f)));
	polepforce += ((-relativevector * Particle0.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecp, polein) + PushConstants.MagneticOffset, 2.0f)));
	vec3 polenforce = vec3(0.0f);
	polenforce += (( relativevector * Particle0.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecn, polein) + PushConstants.MagneticOffset, 2.0f)));
	polenforce += ((-relativevector * Particle0.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecn, poleip) + PushConstants.MagneticOffset, 2.0f))); 
	tot += length(polepforce + polenforce);
	}
	{
	vec3 polecp = Particle0.Position.xyz +  (-Particle1.Magnitude.xyz * barycenterdistance) + ( relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 polecn = Particle0.Position.xyz + -(-Particle1.Magnitude.xyz * barycenterdistance) + ( relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 poleip = Particle1.Position.xyz +  (-Particle1.Magnitude.xyz * barycenterdistance) + (-relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 polein = Particle1.Position.xyz + -(-Particle1.Magnitude.xyz * barycenterdistance) + (-relativevector * barycenterdistance * PushConstants.MagneticOffset * 0.5f);
	vec3 polepforce = vec3(0.0f);
	polepforce += (( relativevector * Particle1.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecp, poleip) + PushConstants.MagneticOffset, 2.0f)));
	polepforce += ((-relativevector * Particle1.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecp, polein) + PushConstants.MagneticOffset, 2.0f)));
	vec3 polenforce = vec3(0.0f);
	polenforce += (( relativevector * Particle1.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecn, polein) + PushConstants.MagneticOffset, 2.0f)));
	polenforce += ((-relativevector * Particle1.MagnitudeVelocity.w) / (4 * PI * pow(distance(polecn, poleip) + PushConstants.MagneticOffset, 2.0f))); 
	tot += length(polepforce + polenforce);
	}
	float magneticfactor = tot * (PushConstants.MagneticStrength * 100);

	//electrostatic part 
	float r2decay = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz) + PushConstants.ElectrostaticOffset), 2.0f);	
	//float electrostaticfactor = length(((((abs(Particle0.PositionVelocity.w) + abs(Particle1.PositionVelocity.w)) / 2) * relativevector) / r2decay) * PushConstants.ElectrostaticStrength);	
	float electrostaticfactor = length((abs(Particle0.PositionVelocity.w * Particle1.PositionVelocity.w) * relativevector) / r2decay) * PushConstants.ElectrostaticStrength;

	ret.pos = (magneticfactor * electrostaticfactor) * relativevector;	
//	fix diamagnetism rotation align or anti align? ;
	//ret.rot = ((Particle0.MagnitudeVelocity.w + Particle1.MagnitudeVelocity.w) / 2) * abs(Particle0.PositionVelocity.w * Particle1.PositionVelocity.w) * (((distance(-relativevector, Particle0.Magnitude.xyz) < distance(relativevector, Particle0.Magnitude.xyz)) ? -relativevector : relativevector) / r23decaydiamagnetism);	
	ret.rot = (magneticfactor * electrostaticfactor) * relativevector;
	return ret;	
}

void main(void)
{
	if (PushConstants.Part == 0)
	{	
	/*
	TODO:

	electrodynamics/EM radiation simulation
	
	proper thermodynamic regulation force that makes the simulation at a set temperature. 
	proper pressure simulation and container simulation
 
	and the other minor forces like precession and circular path 

	v^2 momemtum add ? 

	lorentz transformation
	1 / (1 / sqrt(1 -  (pow(v, 2) / pow(c, 2))))
	cos(arcsin(v / c)) 
	*/
	vec3 totalpos = vec3(0.0f);
	vec3 totalrot = vec3(0.0f);

	float chargec = Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.w;
	float massc = Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w;
	float spinc = Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w;

	float pairedparticleindex = -1.0f;
	float closestelelectronindexa = -1.0f;
	float closestelelectronindexb = -1.0f;
	//float method vs vector method virtually identical. 
	float totalmag = Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w;
	//vec3 totalmag = Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w;
	for (int i = 0; i < PushConstants.Particles; i++) 
	{	
		if (gl_GlobalInvocationID.x != i)
		{	
			float chargei = Particles0.ParticlesS[i].PositionVelocity.w;		
			float massi = Particles0.ParticlesS[i].Position.w;		
			float spini = Particles0.ParticlesS[i].Magnitude.w;		
			float disci = distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz);
			
			//this is how much another particle absorbs a hemisphere of current particles magnetic field, so fully paired would be 0.5 magnetic strengh to anything outside,
			//but the 2 paired particles will experience full force. looping might affect diamagnetism between particles because it just goes around. but it still hits the magnetic field. 	

			//how does partial pairing work kkkk;
			//we really need something for partial pairing wtfi s it;

			//1. new totalmag could explain like if nucleus affects too;
			//2. if this exists then what about other magnetic compression;
			//this current model doesnt even have magnetiism enabled and its weird

			//what if magnetism is irrelvent ? ? 
			//o.0 
			//if we can make bonding work without it then uwaaaaaaaaaa;

			//but didnt we prove that bonding is more due to force adjustment rather
			//then magnetims so uguh :/ hmm a ;

			//central electrons special condition bring back possbily 

			//PARTIAL PAIRING BRO;
			//need to make the offset for it ;
			/*
			low offset electrostatic is better ;

			now do partial pairing ;

			partial pairing last time we tried had problem of not working because forces are wack, forces are no longer wack so should possibly work
			*/
			//so bascially we need to find out what the fuck this below REALLLY Is;
			//it might be anything, mayby even a simple change to current equations.;

			//ugh totalmag does it REALY exist -_-; or do we need to find  what REALY makes radius the way it is and stuff ; v
			//definetely needs a decay at least;
			//in stuff like boron radius only decreases when tghere is asymmetry in pairing which ok. ;

			//totalmag += (-1 / r3decay) * PushConstants.exponent;
			float r3decay = pow(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz) + PushConstants.MagneticOffset, 3);
			totalmag += (-clamp(-(((((-acos(dot(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, Particles0.ParticlesS[i].Magnitude.xyz)) / PI) + 0.5f) * 2) * PushConstants.maxpairing)
						* Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w * Particles0.ParticlesS[i].Magnitude.w), -PushConstants.maxpairing, PushConstants.maxpairing) / r3decay) * PushConstants.exponent;
			
			//optimization indices 
			pairedparticleindex =		(disci < pairingrange && spini != 0.0f && spinc != 0.0f) ? i : pairedparticleindex;					
			closestelelectronindexb =	(disci < MininiumInteractionDistance && spini == 0.0f && spinc != 0.0f && closestelelectronindexa != -1) ? i : closestelelectronindexb;	
			closestelelectronindexb =	(disci < MininiumInteractionDistance && spini != 0.0f && spinc == 0.0f && closestelelectronindexa != -1) ? i : closestelelectronindexb;			
			closestelelectronindexa =	(disci < MininiumInteractionDistance && spini == 0.0f && spinc != 0.0f && closestelelectronindexa == -1) ? i : closestelelectronindexa;	
			closestelelectronindexa =	(disci < MininiumInteractionDistance && spini != 0.0f && spinc == 0.0f && closestelelectronindexa == -1) ? i : closestelelectronindexa;				
			//forces
			if (disci > MininiumInteractionDistance)  
			{ 		
			//Electrostatic
			calcreturn Electrostaticitoc = Calculate_Electrostatic(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i]);
			totalpos += Electrostaticitoc.pos * PushConstants.ElectrostaticStrength;
			totalrot += Electrostaticitoc.rot * PushConstants.ElectrostaticAlignmentStrength;	
			//Magnetism
			calcreturn Magnetismitoc = Calculate_Magnetism(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i]);
			totalpos += Magnetismitoc.pos * PushConstants.MagneticStrength * 0.2f;
			totalrot += Magnetismitoc.rot * PushConstants.MagneticAlignmentStrength;	
			//Diamagnetism
			calcreturn Diamagnetismitoc = Calculate_Diamagnetism(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i]);	
			totalpos += Diamagnetismitoc.pos;
			totalrot += Diamagnetismitoc.rot * PushConstants.DiamagneticAlignmentStrength;	
			}
		}
	}
	Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.w = clamp(totalmag, 0.0f, 1.0f);
	//Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.w = 1.0f;
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x = pairedparticleindex;
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.y = closestelelectronindexa;
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z = closestelelectronindexb;
	//range checks 
	totalpos = length(totalpos) > 0.0f ? totalpos : vec3(0.0f);
	totalpos = length(totalpos) < 100000.0f ? totalpos : vec3(0.0f);
	totalrot = length(totalrot) > 0.0f ? totalrot : vec3(0.0f);
	totalrot = length(totalrot) < 100000.0f ? totalrot : vec3(0.0f);

	//final addition
	Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += totalpos * (PushConstants.Multiplier * 0.1f);
	Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz += totalrot * (PushConstants.Multiplier * 0.1f);
	
	//crucial for integrator 
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz = Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz;
	Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;

	}
	if (PushConstants.Part == 1)
	{	
	Particles0.ParticlesS[gl_GlobalInvocationID.x] = Particles1.ParticlesS[gl_GlobalInvocationID.x];
	
	{//temporary slowdown effect aka cooling
		float bleed = 1.0f - (0.01f * PushConstants.Multiplier);
		Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * bleed;
		Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz = Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz * bleed;
	}
	//container 
	//if (length(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) > 10.0f)
	//{
	//	Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (normalize(-Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) * 0.00001f) * PushConstants.Multiplier;
	//}

	float chargec = Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.w;
	float massc = Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.w;
	float spinc = Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.w;

	float pairedparticleindex = Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x;
	float closestelelectronindexa = Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.y; 
	float closestelelectronindexb = Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z;

	//POSITION
	
	//paired and nuclear position additions.	
	Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz = spinc == 0.0f ? Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz : 
		(pairedparticleindex != -1 ? (closestelelectronindexa != -1 ? Particles1.ParticlesS[int(closestelelectronindexa)].Position.xyz : (Particles1.ParticlesS[int(pairedparticleindex)].Position.xyz + Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) / 2) :
		(closestelelectronindexa != -1 ? Particles1.ParticlesS[int(closestelelectronindexa)].Position.xyz : Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz));
	Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz += ((spinc == 0.0f ? (Particles1.ParticlesS[int(closestelelectronindexa)].PositionVelocity.xyz + Particles1.ParticlesS[int(closestelelectronindexb)].PositionVelocity.xyz + Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz): 
		(pairedparticleindex != -1 ? (closestelelectronindexa != -1 ? vec3(0.0f) : (Particles1.ParticlesS[int(pairedparticleindex)].PositionVelocity.xyz + Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) / 2) :
		(closestelelectronindexa != -1 ? vec3(0.0f) : Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz))) / massc) * (PushConstants.Multiplier * 1.0f);
	
	//unpaired ver
	//Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz = Particles1.ParticlesS[gl_GlobalInvocationID.x].Position.xyz;	
	//Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz += ((Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) / massc) * (PushConstants.Multiplier * 1.0f);
	
	//MAGNITUDE	
	//paired magnitude additions.
//	potentially invalid if multiple rotational transforms are added together like totalrot.;	
	//vec3 combinedtransform = (Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz + Particles1.ParticlesS[int(pairedparticleindex)].MagnitudeVelocity.xyz) / 2;
	//vec3 newmagnitudetransform = pairedparticleindex != -1 ? (distance(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, combinedtransform) < distance(Particles1.ParticlesS[int(pairedparticleindex)].Magnitude.xyz, combinedtransform) ?
	//	combinedtransform : -combinedtransform) : Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz;

	vec3 newmagnitudetransform = Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz;

	if (length(newmagnitudetransform) != 0.0f &&
		length(cross(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(newmagnitudetransform))) > 0.001f &&
		length(cross(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(-newmagnitudetransform))) > 0.001f)
	{
	//rotating magnitude according to magnitudevelocity.
	Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = rotate(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, 
		cross(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(newmagnitudetransform)),
		((acos(dot(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(newmagnitudetransform))) * length(newmagnitudetransform)) / massc) * (PushConstants.Multiplier * 1.0f));
	//needs velocity to be rotated to exactly how much magnitude is  
	Particles0.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz = rotate(Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.xyz, 
		cross(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(newmagnitudetransform)),
		((acos(dot(normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz), normalize(newmagnitudetransform))) * length(newmagnitudetransform)) / massc) * (PushConstants.Multiplier * 1.0f));

	Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz);
	}

	}
}


	/*
	//magnetic only r3 
	float r3decaymagnetismi = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz) + MagneticOffset), 3.0f);
	//vector between field center and particle
	vec3 relativevectori = normalize(Particle0.Position.xyz - Particle1.Position.xyz);
	//scale magneticorientationvector to set distance of magnetic field. 	
	vec3 orientationvectori = -(cross(cross(relativevectori, Particle1.Magnitude.xyz), Particle1.Magnitude.xyz)) * barycenterdistance;
	//how compressed a given degree of the field is due to the particle obstruction.
	//seems like offsets and shit break conservation ;

	//float fieldcompressionfactori = clamp((((acos(dot(normalize(orientationvectori), relativevectori)) / PI) * 2) - 0.8f) * 2, 0.0f, 1.0f);
	float fieldcompressionfactori = clamp((((acos(dot(normalize(orientationvectori), relativevectori)) / PI) * 2) - 0.5f), 0.0f, 1.0f);
	
	//scale by fieldcomrpresion factor adds vector to forcedirection to make it more accurate. ;
	//the further it gets from other particle the less it aligns, negative feedback loop ;
	//so the solution is theres a force that pushes from equator to poles ;
	vec3 relativevectortrue = normalize(relativevectori - (orientationvectori * pow(1 + fieldcompressionfactori, 30)));
	//force going towards poles either way from equator.
	vec3 polarforce = cross(cross(normalize(orientationvectori), relativevectortrue), relativevectortrue);
	 
	//REAR PAIRING IS LESS SRTONG >:c ACTUALLY DUE TO CANCELLATION FORCE.; so what. cancellation should reduce on the primary particle..
	
	//now find direction of it
	vec3 forcedirectioni = normalize(cross(cross(normalize(orientationvectori), Particle1.Magnitude.xyz), relativevectortrue));
	//magnetism from orbital veloecity (UNFIINISHED)
	//vec3 forcedirectionfromvelocity = cross(Particles0.ParticlesS[i].PositionVelocity.xyz, );
	//Magnetic Particle Circular Motion In Magnetic Field Transform.
	//totalpos += cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz, totalmagdirectioni) * 0.000001f;
	//Magnetic Drag Positional Transform
	//totalpos += (length(totalmagdirectioni) * -(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)) * 0.0000001f;	
	//Magnetic Particle Precession Motion In Magnetic Field Transform.
	//rate of precession, theres an equilibrium where the amount of energy deflected by precession = total force exerted;
	//the combined forced should be a combination of this making it precess, and the other one making it normalize;
	//calculating the strength of the precession relative to the normalization is extremely difficult.;
	//totalrot += cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, totalmagdirectioni) * 0.000001f;
	//Magnetic Particle Alignment Transform.
	//totalrot += (totalmagdirectioni * -((((-acos(dot(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz, normalize(totalmagdirectioni))) / PI) + 0.5f) * 2) + 0.5f)) * 0.0000001f;

	float magmul = (Particle0.Acceleration.x + Particle0.Magnitude.w) * (Particle1.Acceleration.x + Particle1.Magnitude.w);
	ret.pos = vec3(0.0f);
	ret.pos += ((relativevectori * magmul) / r3decaymagnetismi) *
					(((-acos(dot(Particle0.Magnitude.xyz, forcedirectioni)) / PI) + 0.5f) * 2);
	how strong should polar force be. it depends on how far from equator, directly proportional to field compression factor . . .
	when field comrpession factor = 1 it is as strong as relativevector transform. 

	ret.pos += ((polarforce * magmul) / r3decaymagnetismi) *
				(((-acos(dot(Particle0.Magnitude.xyz, forcedirectioni)) / PI) + 0.5f) * 2);
	//it doesnt need it needs alignment because of the nature of how magnitude is calculated atm.
	ret.rot = (((-forcedirectioni * (Particle0.Acceleration.x + Particle0.Magnitude.w) * (Particle1.Acceleration.x + Particle1.Magnitude.w))) / r3decaymagnetismi);
		// * (((-acos(dot(Particle0.Magnitude.xyz, forcedirectioni)) / PI) + 0.5f) * 2)*/



	//this is not right;
	//Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.w = spinc != 0.0f ? clamp(length(totalmag), 0.5, 1.0f) : 0.0f;
	//Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.w = clamp(totalmag, 0.0f, 1.0f);


				/*
			induction magnetism;
			but what causes induction? 		
			paired particles rotate? but then valence doesnt produce spectra.. so ugh how 
			theres also distinct layers of excitaiton : / like in hydrogen : / / / 
			wait magnitude rotation can also cause EM emission .. . .

			1. the determinant of the energy levels must be nucleus and other electrons. 
			2. must be able to boost and negate to different energy levels
			3. must have quantized difference . .. . 

			what if its some sort of waveform mixing that results in neat spectra 
			waveform mixing doesnt change frequency hmm just reduces amplitude vb 
			it doesnt really matter if other frequencies are emitted too, just that they cnacel eaechother out 
			i mean the electrons just have to be oscillating in some way. 
			its already probably fine  
			
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x = 0.0f;
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x = spini == 0.0f && spinc != 0.0f ?
			//			((1 / pow(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz) + MagneticOffset, 3)) * Inductionmagnetismstrength) : Particles1.ParticlesS[gl_GlobalInvocationID.x].Acceleration.x;
			*/


					/*
			next step readd polarization dynamics and fine tune them.;
			fiugre out how the 3 forces change rotation;

			1. electrostatic doesnt need rot because diamagnetism is electrostatic interacting with magnetic field so its redundant. and torque from hitting particle itself assymetrically is basicialyl impossible
			2. diamagnetism torque solved by every source creates a polarization force either alignes perpindicularly or parrelel to force vector (already done);
			3. magnetic torque (EXPLAIN) aaa uniform magnetic field only precession? ugh ;
			it is complicated because we know that it precesses but mayby shouldnt it align? or does magnetism just not align particles at all. ? 
			but like there has to be some form of magnetic alignment rigth? or is it all just diamagnetism perpindicular?;
			perpindicular doesnt realy make sense what direction itd align and the structure is inferior. 

			so there must be a magnetic transform of some sort right, so what is it? because precession has to be included;

			1. precession with very slow alignmnet : / not realy
			2. preccession in uniform fields and alignment in non uniform ? i think this is most promising ngl because of the dichotemy. 
			*/	
		
			//Perpindicular Emission Force (light)			
			//a particle accelerated in direction x signicantly enough it releases perpindicular energy that induces motion in particles in direction -x.;
			//also when a particles magnetic field is hit it creates a copy of the impacting wave.;
			//needs to follow dominant frequency theory too;
			//totalpos += ((chargec * chargei) * ((length(Particles1.ParticlesS[i].Acceleration.xyz) > Threshold) ? (-Particles1.ParticlesS[i].Acceleration.xyz / r2decay) : vec3(0.0f))) * 0.1f;
			//Gravitational Force
			//totalpos += ((1.0 / 404331557902116024553602703216.58) / distancesqaured) * pParticle2->Size; // ((0.00000000001) / distancesqaured) * pParticle2->Size
			
			//bonding requires partial pairing but full pairing is more accurate for structure 
			//option a, special case magnetism, self centering. ;
			//so basicially the closer a particle is to a nucleus the more of its magnetism is centered. 
			//it shouldnt add more magnitude then what was already present ; so normalize it by relativevectori ;
			//float decayr3np = pow(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[int(Particles0.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z)].Position.xyz) + MagneticOffset, 3.0f);
			//vec3 nuclearpolarization = normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[int(Particles0.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z)].Position.xyz) / decayr3np;
			//the percentage of relative vector that becomes aligned with nucleus depends on how close it is. r3 or r2;
			//btw this is only the case if there is a paired particle aligned oppisite on the other side of nucleus. symmetrically. so include that.;
			//relativevectori = Particles0.ParticlesS[gl_GlobalInvocationID.x].Acceleration.z != -1 ? 
			//			 ((nuclearpolarization + relativevectori) * (length(relativevectori) / length((nuclearpolarization + relativevectori)))) : relativevectori;


	/*
				/*
			//barycenter of where electrostatic force hits c parrticle from i particle and disperses energy into the lattice. 
			vec3 forcecenteritoc = (Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[i].Position.xyz) / 2;	
			float baselineitoc = distance(forcecenteritoc, Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz);
			for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
			{	
				//it is 1 divisor too much, it starts at 2 . ;
				//why does  * Particles0.ParticlesS[i2].MagnitudeVelocity.w break energy conservation ;
				//oh because it makes 0 and 1 (c and i ) have non 2 divisor 
				float ea = (i2 != gl_GlobalInvocationID.x && i2 != i) ? (Particles0.ParticlesS[i2].Acceleration.x == -1 ? Particles0.ParticlesS[i2].MagnitudeVelocity.w : 0.0f) : 1.0f;
				//ea = (i2 != gl_GlobalInvocationID.x && i2 != i) ? 0.0f : 1.0f;
				//distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) <= baselineitoc
				//also baseline check is required? but need sto be better... baseline makes it jittery
				//divisor += true ? ((1 / pow((distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) / baselineitoc) + MagneticOffset, 3.0f)) * ea) : 0.0f;		
			}
			{
			calcreturn Diamagnetismitoc = Calculate_Diamagnetism(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i], divisor);
			/*if the barycenter is inbetween the 2 particles then lattice litterally doesnt exist 
			vec3 Diamagnetismlattice = vec3(0.0f);
			for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
			{	
				if (gl_GlobalInvocationID.x != i2 && i != i2)
				{	
					float disci2 = distance(Particles0.ParticlesS[i].Position.xyz, Particles0.ParticlesS[i2].Position.xyz);
					if (disci2 > MininiumInteractionDistance) 
					{
					Diamagnetismlattice += Calculate_LatticeDiamagnetism(Particles0.ParticlesS[i], Particles0.ParticlesS[i2], int(gl_GlobalInvocationID.x));
					}
				}
			}		
			totalpos += Diamagnetismlattice * DiamagneticStrength;	
			totalpos += Diamagnetismitoc.pos * DiamagneticStrength;	
			totalrot += Diamagnetismitoc.rot * MagneticAlignmentStrength;	
			}
			{
			calcreturn Magnetismitoc = Calculate_Magnetism(Particles0.ParticlesS[gl_GlobalInvocationID.x], Particles0.ParticlesS[i], divisor);
			/*if the barycenter is inbetween the 2 particles then lattice litterally doesnt exist 
			vec3 Magnetismlattice = vec3(0.0f);
			for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
			{	
				if (gl_GlobalInvocationID.x != i2 && i != i2)
				{	
					float disci2 = distance(Particles0.ParticlesS[i].Position.xyz, Particles0.ParticlesS[i2].Position.xyz);
					if (disci2 > MininiumInteractionDistance) 
					{
					Magnetismlattice += Calculate_LatticeMagnetism(Particles0.ParticlesS[i], Particles0.ParticlesS[i2], int(gl_GlobalInvocationID.x));
					}
				}
			}		
			//totalpos += Magnetismlattice * MagneticStrength;	
			totalpos += Magnetismitoc.pos * MagneticStrength;		
			totalrot += Magnetismitoc.rot * MagneticAlignmentStrength;	
			}


	for (int i = 0; i < PushConstants.Particles; i++) 
	{	
		if (gl_GlobalInvocationID.x != i)
		{	
			float chargei = Particles0.ParticlesS[i].PositionVelocity.w;		
			float massi = Particles0.ParticlesS[i].Position.w;		
			float spini = Particles0.ParticlesS[i].Magnitude.w;		
			float disci = distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz);
			
			float r3decay = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[i].Position.xyz) + MagneticOffset), 6.0f);
			totalmag += ((Particles0.ParticlesS[i].Magnitude.xyz * Particles0.ParticlesS[i].Magnitude.w) / r3decay) * pow(MagneticOffset, 6.0f);		

			//if interacting particle and current particle are electrons and they are close enough, they pair. is exclusive.
			pairedparticleindex = (disci < pairingrange && spini != 0.0f && spinc != 0.0f) ? i : pairedparticleindex;	
			closestelelectronindexa = (disci < MininiumInteractionDistance && spini == 0.0f && spinc != 0.0f) ? i : closestelelectronindexa;	
			closestelelectronindexa = (disci < MininiumInteractionDistance && spini != 0.0f && spinc == 0.0f) ? i : closestelelectronindexa;	
		}
	}*/
	//float r3decaye = pow((distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[int(closestelelectronindexa)].Position.xyz) + MagneticOffset), 3.0f);
	//vec3 averagedir = spinc != 0.0f ? (normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[int(closestelelectronindexa)].Position.xyz) / r3decaye) : vec3(0.0f);
	//it needs to be the average density over the path of electrostatic from center of particle to other particle. ; i dont think its sqrt its linear
	//spinc of nucleus cant be canceled out unless its a fucking nucleus with net spin. but its always cancelled out
	//Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.w = (spinc != 0.0f ? clamp(length(totalmag), 0.5f, 1.0f) : 0.5f); // + (1 / r3decaye)
	//Particles1.ParticlesS[gl_GlobalInvocationID.x].MagnitudeVelocity.w = (spinc != 0.0f ? clamp(length(totalmag), 0.5f, 1.0f) : 0.0f);
	//totalrot += ((distance(-averagedir, Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz) < distance(averagedir, Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz)) ? -averagedir : averagedir) * ForceInducedRotationStrength;	

	//innermost eletrons definetely do have a few forces helping.;
	//totalrot += pairedparticleindex == -1 ? vec3(0.0f) : -Particles0.ParticlesS[int(pairedparticleindex)].Magnitude.xyz;
	//add something to lock central electrons for optimization;
	//totalpos += distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz, Particles0.ParticlesS[int(closestelelectronindexa)].Position.xyz) < (MininiumInteractionDistance * 2) ?
	//			(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[int(closestelelectronindexa)].Position.xyz) : vec3(0.0f);

/*

vec3 Calculate_LatticeDiamagnetism(Particle Particle0, Particle Particle1, int c, int i)
{
	float r23decaydiamagnetismi = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz) + MagneticOffset), 6.0f);
	//electrostatic flux strength determines repulsion strength.
	vec3 forcepos = abs(Particle1.PositionVelocity.w * Particle0.PositionVelocity.w) * (normalize(Particle0.Position.xyz - Particle1.Position.xyz) / r23decaydiamagnetismi);			
	//barycenter of where electrostatic force hits c parrticle from i particle and disperses energy into the lattice. 
	//biased to one side? it seems like 0.5 makes difference between hydrogen and helium less rather then 0.1 hmmm...
	//0.8 is less accurate then 0.5 and 0.1 is less accurate hten 0.5 
	//theoretical predictions say it should be from like 0.5-0.8 on average.
	//vec3 forcecenteritoc = Particle1.Position.xyz + ((Particle0.Position.xyz - Particle1.Position.xyz) * percentoffset);	
	vec3 forcecenteritoc = (Particle1.Position.xyz + Particle0.Position.xyz) / 2;
	//it can take its own lattice tho ; instead, lattice set originaly to 0. ;
	float aa = 0.0f;
	float lowpointitoc = 0.0f;
	float baselineitoc = distance(forcecenteritoc, Particle0.Position.xyz);
	for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
	{	
		float e = distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) <= baselineitoc ?
						((1 / pow((distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) / baselineitoc) + MagneticOffset, 6.0f)) * Particles0.ParticlesS[i2].MagnitudeVelocity.w) : 0.0f;	
		//if i2 = c then save how much it adds and then divide that by the total divisor to get the percentage of the force that c has got. ;
		lowpointitoc += e;
	//	pretty sure this breaks energy conservation because izz un balance   
		aa = (i2 == c) ? e : aa;
	}
	return ((forcepos * Particle1.MagnitudeVelocity.w * Particle0.MagnitudeVelocity.w) / lowpointitoc) * (aa / lowpointitoc);
}
vec3 Calculate_LatticeMagnetism(Particle Particle0, Particle Particle1, int c, int i)
{
	float r23decaydiamagnetismi = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz) + MagneticOffset), 6.0f);
	vec3 orientationvectori = normalize(cross(cross((Particle1.Position.xyz - Particle0.Position.xyz), Particle1.Magnitude.xyz), Particle1.Magnitude.xyz)) * barycenterdistance;
	vec3 relativevectori = normalize(Particle0.Position.xyz - (Particle1.Position.xyz + orientationvectori));
	//float r3decayi = pow((distance(Particle0.Position.xyz, Particle1.Position.xyz + orientationvectori.xyz) + MagneticOffset), 3.0f);
	//vec3 forcedirectioni = normalize(cross(cross(orientationvectori, Particle1.Magnitude.xyz), relativevectori));
	//vec3 totalmagdirectioni = (forcedirectioni * Particle0.Magnitude.w * Particle1.Magnitude.w) / r23decaydiamagnetismi; 
	vec3 totalmagrelativei = ((relativevectori * Particle0.Magnitude.w * Particle1.Magnitude.w) / r23decaydiamagnetismi);
	vec3 forceitoc = totalmagrelativei * (((-acos(dot(Particle0.Magnitude.xyz, Particle1.Magnitude.xyz)) / PI) + 0.5f) * 2);			
	//barycenter of where electrostatic force hits c parrticle from i particle and disperses energy into the lattice. 
	//biased to one side? it seems like 0.5 makes difference between hydrogen and helium less rather then 0.1 hmmm...
	//0.8 is less accurate then 0.5 and 0.1 is less accurate hten 0.5 
	//theoretical predictions say it should be from like 0.5-0.8 on average.
	//vec3 forcecenteritoc = Particle1.Position.xyz + ((Particle0.Position.xyz - Particle1.Position.xyz) * percentoffset);	
	vec3 forcecenteritoc = (Particle1.Position.xyz + Particle0.Position.xyz) / 2;
	//it can take its own lattice tho ; instead, lattice set originaly to 0. ;
	float aa = 0.0f;
	float lowpointitoc = 0.0f;
	float baselineitoc = distance(forcecenteritoc, Particle0.Position.xyz);
	for (int i2 = 0; i2 < PushConstants.Particles; i2++) 
	{	
		float e = distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) <= baselineitoc ?
						((1 / pow((distance(forcecenteritoc, Particles0.ParticlesS[i2].Position.xyz) / baselineitoc) + MagneticOffset, 6.0f)) * Particles0.ParticlesS[i2].MagnitudeVelocity.w) : 0.0f;	
		//if i2 = c then save how much it adds and then divide that by the total divisor to get the percentage of the force that c has got. ;
		lowpointitoc += e;
		aa = (i2 == c) ? e : aa;
	}
	return ((forceitoc * Particle1.MagnitudeVelocity.w * Particle0.MagnitudeVelocity.w) / lowpointitoc) * (aa / lowpointitoc);
}*/


	/*

		{
	/*
	vec3 relap = normalize(vec3(-totaldiamagp.x, totaldiamagp.y, -totaldiamagp.z));
	mat3 rotp = mat3(
	relap.y, -relap.x, 0,
	relap.x, relap.y, relap.z,
	0,		-relap.z, relap.y
	);
	vec3 irelap = normalize(vec3(totaldiamagp.x, totaldiamagp.y, totaldiamagp.z));
	mat3 irotp = mat3(
	irelap.y, -irelap.x, 0,
	irelap.x, irelap.y, irelap.z,
	0,		 -irelap.z, irelap.y
	);
	vec3 relan = normalize(vec3(-totaldiamagn.x, totaldiamagn.y, -totaldiamagn.z));
	mat3 rotn = mat3(
	relan.y, -relan.x, 0,
	relan.x, relan.y, relan.z,
	0,		-relan.z, relan.y
	);
	vec3 irelan = normalize(vec3(totaldiamagn.x, totaldiamagn.y, totaldiamagn.z));
	mat3 irotn = mat3(
	irelan.y, -irelan.x, 0,
	irelan.x, irelan.y, irelan.z,
	0,		 -irelan.z, irelan.y
	);
	//needs p and n to be transformed to the plane of the subtractor? so then can get the subtraction caps which is y 0 to cap the subtraction,
	//and then subtract transformed n from transformed p or vice versa to get the transform making sure it does violate the caps,
	//and then transform back from plane of subtractor; 
	vec3 totaldiamagtnp = rotn * totaldiamagp;
	vec3 totaldiamagtnn = rotn * totaldiamagn;

	vec3 totaldiamagtpp = rotp * totaldiamagp;
	vec3 totaldiamagtpn = rotp * totaldiamagn;
	//PN DOESNT FUCKING DO ANYTHING ;
	vec3 totaldiamagpn = (length(totaldiamagn) != 0.0f && length(totaldiamagp) != 0.0f ?
						 (irotn * vec3(totaldiamagtnp.x, (sign(totaldiamagtnp.y - totaldiamagtnn.y) == sign(totaldiamagtnp.y) ? (totaldiamagtnp.y - totaldiamagtnn.y) : 0.0f), totaldiamagtnp.z)) : totaldiamagp) +
						 (length(totaldiamagp) != 0.0f && length(totaldiamagn) != 0.0f ?
						 (irotp * vec3(totaldiamagtpn.x, (sign(totaldiamagtpn.y - totaldiamagtpp.y) == sign(totaldiamagtpn.y) ? (totaldiamagtpn.y - totaldiamagtpp.y) : 0.0f), totaldiamagtpn.z)) : totaldiamagn);
	
	}

	

	//iteratively parse all octants in the chunk using the position it came up from  
	//to find the next octant to parse, once all octants are parsed, move up.
	//fix these indexes
	ivec3 next[2][2][2] ={	{{ivec3(1, 0, 0), ivec3(1, 0, 1)},	{ivec3(1, 1, 0),  ivec3(1, 1, 1)}},
							{{ivec3(0, 1, 0),  ivec3(0, 1, 1)},	{ivec3(0, 0, 1),  ivec3(-1, -1, -1)}}};
	
	int CurrentIndex = 0;
	ivec3 Coordinate = ivec3(0);
	while (CurrentIndex != -1)
	{	
		if (distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
					 Particles0.ParticlesS[CurrentIndex].Position.xyz) < 0.4 && CurrentIndex != gl_GlobalInvocationID.x)
		{
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = 
				((Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz * Particles0.ParticlesS[CurrentIndex].Position.w)
				* (-clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz) - 0.05f, 0.0f, 1.0f) + 1.0f)) 
				+ ((Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)
				* clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz), 0.0f, 1.0f));
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
		}
			
		if (distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz,
					 Particles0.ParticlesS[CurrentIndex].Position.xyz + Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz) < 0.4 && CurrentIndex != gl_GlobalInvocationID.x)
		{
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = 
				((Particles0.ParticlesS[CurrentIndex].PositionVelocity.xyz * Particles0.ParticlesS[CurrentIndex].Position.w)
				* (-clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz) - 0.05f, 0.0f, 1.0f) + 1.0f)) 
				+ ((Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz)
				* clamp(distance(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz,
				Particles0.ParticlesS[CurrentIndex].Position.xyz), 0.0f, 1.0f));
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
		}
		
		//get octant index from...	
		ivec3 NextChunk = next[Coordinate.x][Coordinate.y][Coordinate.z];
		if (NextChunk == ivec3(-1, -1, -1)) //all octants in this node have been parsed, go up.
		{
			int indextemp = CurrentIndex;
			CurrentIndex = int(Particles0.ParticlesS[CurrentIndex].PositionVelocity.w);

			//get center of particle's chunk.
			float LevelChunkSize0 = (float(PushConstants.Resolution) / pow(2.0f, float(Particles0.ParticlesS[CurrentIndex].level)));
			float ChunkSizeOffset0 = ((LevelChunkSize0 / 2.0f));
			vec3 CurrentChunkPosition = (round((Particles0.ParticlesS[CurrentIndex].Position.xyz) / ChunkSizeOffset0) * ChunkSizeOffset0);

			Coordinate = ivec3(clamp(((((Particles0.ParticlesS[indextemp].Position.xyz) - (CurrentChunkPosition.xyz)) + 1.0f) / 2), 0.0, 1.0));
			//if parent == -1 then its the root. and end the algorithm.
		}
		else //if not all octants are parsed...
		{	
			//go down if octant has valid data, otherwise stay at current index and increment overload.
			//ignore if chunk doesnt intersect original particle interaction radius.

			float LevelChunkSize0 = (float(PushConstants.Resolution) / pow(2.0f, float(Particles0.ParticlesS[Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z]].level)));
			float ChunkSizeOffset0 = ((LevelChunkSize0 / 2.0f));
			vec3 CurrentChunkPosition = (round((Particles0.ParticlesS[Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z]].Position.xyz) / ChunkSizeOffset0) * ChunkSizeOffset0);

			if (Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z] != -1 &&
			OverlapCube((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - vec3(0.41)), 
						(Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + vec3(0.41)),
						CurrentChunkPosition.xyz - vec3(LevelChunkSize0 * 8),
						CurrentChunkPosition.xyz + vec3(LevelChunkSize0 * 8)) == true)
			{ 		
				Coordinate = ivec3(0);
				CurrentIndex = Particles0.ParticlesS[CurrentIndex].Info0[NextChunk.x][NextChunk.y][NextChunk.z];						
			}
			else 
			{
				Coordinate = ivec3(NextChunk);
			}		
		}

	}*/

				/*
			aa rela is wrong
			vec3 rela = normalize(vec3(-Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.x, Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.y, -Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.z));

			mat3 rot = mat3(
			rela.y, -rela.x, 0,
			rela.x, rela.y, rela.z,
			0,		-rela.z, rela.y
			);

			vec3 relamagA = rot * modmagA;
			vec3 relamagS = rot * modmagS;
			*/
			//vec3 magc = rot * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;
			//vec3 magi = rot * Particles0.ParticlesS[i].Magnitude.xyz;

			//EQUATION OF TRUE NATURE OF ENERGY
			//vec3 xc = (cross((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 yc = (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);
			//vec3 zc = (cross(cross((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz - Particles0.ParticlesS[i].Position.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));

			//vec3 xi = (cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz));
			//vec3 yi = (Particles0.ParticlesS[i].PositionVelocity.xyz);
			//vec3 zi = (cross(cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz));

			//vec3 relativemagc = ((xc * magc.x) + (yc * magc.y) + (zc * magc.z));
			//vec3 relativemagi = ((xi * magi.x) + (yi * magi.y) + (zi * magi.z));
			/*
			velocity and magnitude should both be conserved and be related.

			magnitude is when velocity is cancelled out?? like p - n  ? is that really what magnitude is?? the restoring force to energy cancellation? or the conservation?

			what would magnitude have to be for gravity to work.

			vec3 aaa = Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz - Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz;
			//aaa = zc;

			//the equation doesnt like if position is the same between i and c

			mat3 inv = inverse(mat3(
			xc.x, xc.y, xc.z,
			yc.x, yc.y, yc.z,
			zc.x, zc.y, zc.z));

			aaa = (inv) * aaa;

			vec3 modmagnitude = aaa;
			*/
			//SUBTRACTING THE ENERGY FROM THE MAGNITUDE TO SATISFY CONSERVATION OF ENERGY.
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz -= (modmagnitude) * 0.1;

			//ADDING THE ENERGY TO THE MAGNITUDE ADJUSTED FOR VELOCITY AND DIRECTION.
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += (modmagnitude) * 0.0000001;
		//	Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz);

		
			/*
			//reverse relative to velocity c pls .
			vec3 magaddA = (magi + magc); 

			in situations where magaddA is 0, it doesnt need to transform anyways so its fine;

			vec3 relaA = vec3(-magaddA.x, magaddA.y, -magaddA.z);		
			mat3 rotA = mat3(
			relaA.y, -relaA.x, 0,
			relaA.x, relaA.y, relaA.z,
			0,		-relaA.z, relaA.y
			);
			vec3 rotmagi = rotA * magi;

			vec3 relacA = vec3(-magc.x, magc.y, -magc.z);		
			mat3 rotcA = mat3(
			relacA.y, -relacA.x, 0,
			relacA.x, relacA.y, relacA.z,
			0,		-relacA.z, relacA.y
			);
			vec3 rotmagc = rotcA * magc;

			velc will never be 0 so its fine.;

			vec3 relvelcc = vec3(velc.x, velc.y, velc.z);		
			mat3 rotrelvelcc = mat3(
			relvelcc.y, -relvelcc.x, 0,
			relvelcc.x, relvelcc.y, relvelcc.z,
			0,		-relvelcc.z, relvelcc.y
			);			

			magc might be 0 so figure out what happens. if magc is 0 then transform is in line with velc

			vec3 relmagcc = vec3(magc.x, magc.y, magc.z);	
			mat3 rotrelmagcc = mat3(
			relmagcc.y, -relmagcc.x, 0,
			relmagcc.x, relmagcc.y, relmagcc.z,
			0,		-relmagcc.z, relmagcc.y
			);	

			vec3 modmagA = (rotmagc - rotmagi);

									//THIS IS THE TRANSFORM VECTOR TO SATISFY 3D ENERGY CONSERVATION.
			//vector goes from interacting to current
			//MAKE RELATIVE MAGNITUDEDIFFERENCE!!!! mayby subtract?? 

			vec3 eq = vec3(0, 1, 0) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz; // 0 or 2
			//THSI CAN EITHER BE 2 or -2 IN OPPOSITE MAGNITUDE INT ERACTIONS DEPENDING ON WHAT ONE IS CURREMT, NOT RIGHT. MUST BE RELATIVE!! IE OPPOSITE MUST ALWAYS BE -2
			//1 + 0 when align, -1 + 2 when opposite.
			vec3 addvec = (normalize(normalize(Particles0.ParticlesS[i].Magnitude.xyz) + (-eq)) - normalize(normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz) + (eq)));
			//vec3 addvec = ((Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz) - (Particles0.ParticlesS[i].Magnitude.xyz)) * Particles0.ParticlesS[i].Magnitude.y;
			//vec3 addvec = vec3(0, 1 * (Particles0.ParticlesS[i].Magnitude.y * Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.y), 0);

			//this makes it -2 to 0 instead of -2 to 2 for example
			//addvec +=  vec3(0, 1, 0) - Particles0.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;
			addvec += vec3(0, 1, 0);	


			//ADD VECTOR NEEDS TO BE ROTATED IN LINE WITH THE VECTOR OF THE INTERACTING ENERGY;
			//GETTING THE AXISES 
			//if one of the are inverted just flip one of these axis;
			vec3 x = cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz);
			vec3 y = Particles0.ParticlesS[i].PositionVelocity.xyz;
			vec3 z = (Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz); //z might be wrong

			//ROTATING THE VECTOR
			vec3 modmag = (x * addvec.x) + (y * addvec.y) + (z * addvec.z);


			//does this need?, yes it does, but find out more about magnitude;
			//removing velocity to other particles;
			//mayby this should be before adding??;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += modmag * 0.01; 
			
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz -= Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * 0.01;
	
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = normalize(Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);

			//DO GRAVITY WHICH IS POSITIONAL NORMALIZATION AND MAGNITUDE CHANGE.

			//			gravity needs to increase magnitude in z

			//Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += vec3(0, 0, 0.01);
			/*
			//MAGNITUDE
			ADD MAGNITUDE UNTIL NORMALIZATION (normalization means no potential difference);
			normalization of perpindicular;
			turn magmod into magnitude relative to the current vector;
			try to use an inverse of the axis redefine function;

			vec3 addvec1 = ((Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) -
						   (Particles0.ParticlesS[i].Position.xyz + Particles0.ParticlesS[i].PositionVelocity.xyz));

			vec3 x1 = cross((Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz), Particles0.ParticlesS[i].PositionVelocity.xyz);
			vec3 y1 = Particles0.ParticlesS[i].PositionVelocity.xyz;
			vec3 z1 = (Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz); //z might be wrong

			//vec3 magmod = (x1 * addvec1) + (y1 * addvec1) + (z1 * addvec1);

			JUST GET DISTANCE BETWEEN VECTOR AND AXIS BRO;

			distance(x1, addvec1)

			float x = (x1 * addvec1);
			float y = (y1 * addvec1);
			float z = (z1 * addvec1);


			vec3 finalvec1 = magmod 
			efse;



			remove magnitude too;
			mayby this should be before adding??;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz -= Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz;

			Particles1.ParticlesS[gl_GlobalInvocationID.x].Magnitude.xyz += magmod * 0.001; 
			*/

			/*
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (Particles0.ParticlesS[i].PositionVelocity.xyz * (Particles0.ParticlesS[i].Position.w * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w)) * 0.001;
			//REMOVE ENERGY TOO!
			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz -= (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz) * 0.001;

			//ADD THE GRAVITY. l o l 

			Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += (Particles0.ParticlesS[i].Position.xyz - Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz) * 0.001;
			//does it also need to subtract?
			*/
			/*
			vec3 v0 = (Particles0.ParticlesS[i].PositionVelocity.xyz); // * (Particles0.ParticlesS[i].Position.w * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w)
			vec3 v1 = (Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz);

			vec3 DifferenceV = normalize((Particles0.ParticlesS[i].Position.xyz + v0) - (Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.xyz + v1));
			vec3 midvector = normalize(cross(v1, v0));

			
			vec3 eee =  normalize(midvector) - normalize(cross(v1, DifferenceV));
			if (length(eee) == 2.0f)
			{
				midvector *= -1.0f;
			}
			
			//this kicks it off deadzones
			//if (length(midvector) != 1.0f)
			{
				//midvector = -normalize(cross(DifferenceV, v1));
			}
			//midvector = -normalize(cross(DifferenceV, v1));
			//vec3 midvector = normalize(cross(DifferenceV, Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 midvector = normalize(cross(cross(cross(DifferenceV, Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz), Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz));
			//vec3 midvector = normalize(cross(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz * Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w, Particles0.ParticlesS[i].PositionVelocity.xyz * Particles0.ParticlesS[i].Position.w));
			
			//if (length(midvector) == 1.0f)
			{


			//float angle = -acos(dot(normalize(Particles0.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz	* Particles0.ParticlesS[gl_GlobalInvocationID.x].Position.w	),
			//						normalize(Particles0.ParticlesS[i].PositionVelocity.xyz							* Particles0.ParticlesS[i].Position.w						)
			//					  )) * 0.00005;
			float angle = 0.005f;
			//float angle = distanceVP * 0.01;

			// Right Hand, Rodrigues' rotation formula:
			//	v = v*cos(t) + (kxv)sin(t) + k*(k.v)(1 - cos(t))
			
			vec3 v = Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz;
			vec3 v1, v2;
			float c = cos(angle);
			float s = sin(angle);
			vec3 k = normalize(midvector);			
			v1 = v*c;
			v2 = cross(k,v);
			v2 = v2*s;
			v1 = v1+v2;
			v2 = k*(dot(k, v) * (1.0f - c));
			v = v1+v2;
			//applying the transform
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz = v;
			}
			
			//Particles1.ParticlesS[gl_GlobalInvocationID.x].PositionVelocity.xyz += normalize(differencep) * 0.01;
			

			*/

